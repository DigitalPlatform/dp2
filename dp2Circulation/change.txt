1.0.0.86版

1) 新增册统计窗和书目统计窗

---

1.0.0.88版

2007/10/18

1) 书目检索窗可以使用__id途径进行记录索引号范围检索了。输入类似“1-10”这样的检索词。注意不支持逗号间隔的分段。这个功能需要最新版的dp2libraryws支持。

2) 书目检索窗新增导出“记录路径文件”功能。

3) 种册窗有一个错误：当利用“删除书目记录”按钮操作后，MARC编辑器和实体列表都会变为disabled状态，但当随后立即用“保存书目记录”按钮保存记录回数据库后，disabled状态不会变回enabled状态。这个错误已经改正。

4) 实体查询窗新增导出“记录路径文件”和“册条码号文件”功能。

5) 菜单“帮助/参数设置”所打开的“参数配置”对话框，增加了一个propertypage“检索”。里面有3个配置事项：书目检索窗最大命中条数、读者查询窗最大命中条数、实体查询窗最大命中条数，分别可以控制3种窗口的检索最大命中条数。

这些参数如果设置为-1，表示不限制。提供这些配置参数以前，原来3种窗口的缺省配置参数为1000,-1,-1。


---

1.0.0.89版

2007/10/19

1) 为书目检索窗、读者查询窗、实体查询窗的命中记录列表增加了鼠标左键点击栏目标题后排序的功能。

2) 为种册管理窗中的实体记录信息增加了<volume>元素，表示各册的卷号。为此，dp2libraryws图书馆应用服务器也进行了升级。

---

1.0.0.91版

2007/10/26

1) 为满足“借阅排行”统计方案的一些要求，针对OperLogStatisForm(宿主)进行了修改。

---

1.0.0.94版

2007/11/6

由于这个版本更换了数字签名证书，只能把以前的版本在控制面板中卸载后，才能安装新版本。

重新安装后，若干统计方案在dp2circulation中会丢失。这些统计方案可在下面这个地址找到，并重新导入：

http://dp2003.com/dp2bbs/article.aspx?board=@__2&id=205

1) 批修改册窗中，“文件驱动”page的“条码号文件名”旁增加了一个“...”按钮，用途是查找条码文件名。

2) 批修改册窗中，遇到条码为多条记录所用的情况，现在软件在装载这样的条码的对应记录时会报错。工作人员需要将条码重复使用情况排除后，才能利用批修改册窗对册记录进行修改。

3) 书目查询窗、实体查询窗、读者查询窗中，当正在装入浏览记录的时候关闭窗口，会报错。此错误已经被改正。

---

1.0.0.95

2007/11/12

1) 原来版本读者窗中调入空白工作单后然后保存，API SetReaderInfo()的strOldXml参数不为空，这个错误已经改正。

原来版本和dp2libraryws新版本配套使用会报错。

2) 原来版本读者窗中删除一条读者记录后，重新保存，API SetReaderInfo()的strAction参数值为"new"，不对，应该为"change"。这个错误已经改正。

原来版本和dp2libraryws新版本配套使用会报错。

---

1.0.0.96

2007/11/15

1) 为二次开发的宿主类BiblioStatis增加了成员

        public List<ItemInfo> ItemInfos

---

1.0.0.97

2007/11/21

1) 种册管理窗增加了“对象”tabpage。在这里可以增删改书目记录所属的资源对象。

---

1.0.0.98

2007/11/22

1) 原来的版本，读者查询窗中，无法将重复条码记录中后面的条装入读者窗。现在已经给浏览框中右鼠标键popupmenu增加了一个“根据记录路径装入到读者窗”命令，用这个命令可以把重复条码的记录中后面的条装入读者窗。

2) 原来的版本，读者窗中如果装入了重复条码的其中一条读者记录，用“删除”按钮无法删除。现在依然保留这个效果(一般删除的时候不是用记录路径进行删除，而是用条码进行删除，因此会出现删除不了并报警的情况)，但是增加了一个功能：按住CTRL键的同时点删除按钮，就可以根据该记录的路径来进行删除 -- 就可以删除重复条码的记录了。

不过删除的成功仍然需要一些前提条件：即将被删除的记录没有流通信息，即没有借还信息和违约交费信息才行。

---

1.0.0.102

2007/12/11

1) 种册管理窗中，MARC编辑器的CTRL+A功能，原来版本是从相应书目库的cfgs/dp2_autogen.cs和cfgs/dp2_autogen.cs.ref中获得C#脚本并执行，现在改为从相应书目库的cfgs/dp2circulation_marc_autogen.cs和cfgs/dp2circulation_marc_autogen.cs.ref中获得C#脚本并执行。并且脚本代码因为所涉及的部分类库功能调整而需要修改才能通过编译。

2) 增加流通凭条打印功能。可以打印读者的借、还、违约金情况。


~~~

        void menu_createBorrowListReport_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            string strUsedDateRange = this.MainForm.AppInfo.GetString("reportform",
    "borrowlist_daterange",
    "2013");

            string strDateRange = InputDlg.GetInput(
    this,
    "创建报表",
    "请指定时间范围: ",
    strUsedDateRange,
    this.MainForm.DefaultFont);
            if (strDateRange == null)
                return;

            this.MainForm.AppInfo.SetString("reportform",
                "borrowlist_daterange",
                strDateRange);

            // 输出文件目录
            FolderBrowserDialog dlg = new FolderBrowserDialog();

            dlg.Description = "请报表输出的目录:";
            dlg.RootFolder = Environment.SpecialFolder.MyComputer;
            dlg.SelectedPath = this.MainForm.AppInfo.GetString("reportform",
    "borrowlist_output_dir",
    "");

            if (dlg.ShowDialog() != DialogResult.OK)
                return;

            // 检查输出目录是否符合规则
            // 不能使用根目录
            string strRoot = Directory.GetDirectoryRoot(dlg.SelectedPath);
            if (PathUtil.IsEqual(strRoot, dlg.SelectedPath) == true)
            {
                strError = "报表输出目录 '" + dlg.SelectedPath + "' 不合法。不能是根目录";
                goto ERROR1;
            }

            DirectoryInfo di = new DirectoryInfo(dlg.SelectedPath);
            FileSystemInfo [] infos = di.GetFileSystemInfos();
            if (infos.Length > 0)
            {
                DialogResult temp_result = MessageBox.Show(this,
"输出目录  中已经存在内容。\r\n\r\n是否要清除里面的全部子目录和文件?",
"ReportForm",
MessageBoxButtons.YesNo,
MessageBoxIcon.Question,
MessageBoxDefaultButton.Button2);
                if (temp_result == System.Windows.Forms.DialogResult.Yes)
                {
                    // 清除目录中的全部内容
                    // 删除对象目录，然后重建
                    try
                    {
                        PathUtil.DeleteDirectory(dlg.SelectedPath);
                        PathUtil.CreateDirIfNeed(dlg.SelectedPath);
                    }
                    catch (Exception ex)
                    {
                        strError = "清除 输出目录 '" + dlg.SelectedPath + "' 内原有子目录和文件时发生错误： " + ex.Message;
                        goto ERROR1;
                    }
                }
            }

            this.MainForm.AppInfo.SetString("reportform",
    "borrowlist_output_dir",
    dlg.SelectedPath);

            string strOutputDir = dlg.SelectedPath;

            List<string> librarycodes = new List<string>();
            foreach (ListViewItem item in this.listView_libraryConfig.SelectedItems)
            {
                string strLibraryCode = ListViewUtil.GetItemText(item, 0);
                librarycodes.Add(strLibraryCode);
            }

            EnableControls(false);

            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在创建报表 ...");
            stop.BeginLoop();

            try
            {
                this._connectionString = GetOperlogConnectionString();  //  SQLiteUtil.GetConnectionString(this.MainForm.UserDir, "operlog.bin");
                // 创建报表阶段需要的附加索引
                nRet = OperLogLine.CreateAdditionalIndex(
                    this._connectionString,
                    out strError);
                if (nRet == -1)
                    goto ERROR1;



                foreach (string strLibraryCode in librarycodes)
                {
                    XmlNode nodeLibrary = this._cfg.GetLibraryNode(strLibraryCode);
                    if (nodeLibrary == null)
                    {
                        strError = "在配置文件中没有找到馆代码为 '" + strLibraryCode + "' 的 <library> 元素";
                        goto ERROR1;
                    }

                    string strCfgFile = "";
                    // 根据配置文件类型，找到配置文件名
                    nRet = FindCfgFileByType(nodeLibrary,
                        "131",
                        out strCfgFile,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;
                    if (nRet == 0)
                    {
                        strError = "当前分馆 '" + strLibraryCode + "' 没有配置 131 类型的配置文件";
                        goto ERROR1;
                    }

                    string strColumnSortStyle = GetColumnSortStyle(strCfgFile);
                    if (string.IsNullOrEmpty(strColumnSortStyle) == true)
                        strColumnSortStyle = "1:a";
                    else
                        strColumnSortStyle = SortColumnCollection.NormalToTable(strColumnSortStyle);


                    Hashtable macro_table = new Hashtable();
                    macro_table["%library%"] = strLibraryCode;

                    Table reader_table = null;

                    // 获得一个分馆内读者记录的证条码号和单位名称
                    nRet = GetAllReaderDepartments(
                            strLibraryCode,
                            ref reader_table,
                            out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    reader_table.Sort("1:a,-1:a");

                    stop.SetProgressRange(0, reader_table.Count);
                    for (int i = 0; i < reader_table.Count; i++)
                    {
                        Application.DoEvents();
                        if (stop != null && stop.State != 0)
                        {
                            strError = "用户中断...";
                            goto ERROR1;
                        }

                        Line line = reader_table[i];
                        string strReaderBarcode = line.Entry;
                        string strName = line.GetString(0);
                        string strDepartment = line.GetString(1);

                        string strDepartmentName = strDepartment.Replace(" ", "_");
                        if (string.IsNullOrEmpty(strDepartmentName) == true)
                            strDepartmentName = "其他部门";

                        string strOutputFileName = Path.Combine(strOutputDir,
                            strLibraryCode + "\\" + strDepartmentName + "\\" + strReaderBarcode + "_" + strName.Replace(" ", "")+ ".xlsx");

                        stop.SetMessage("正在创建报表文件 " + strOutputFileName + " " + (i + 1).ToString() + "/" + reader_table.Count.ToString() + " ...");

                        // 确保目录被创建
                        // PathUtil.CreateDirIfNeed(Path.GetDirectoryName(strOutputFileName));

                        Table tableList = null;
                        nRet = CreateReaderReport(
                            strLibraryCode,
                            strDateRange,
                            "131",
                            strReaderBarcode,
                            ref tableList,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;

                        tableList.Sort(strColumnSortStyle);  // "1:a" 按照借书时间排序

                        macro_table["%name%"] = strName;
                        macro_table["%department%"] = strDepartment;
                        macro_table["%readerbarcode%"] = strReaderBarcode;

                        macro_table["%linecount%"] = tableList.Count.ToString();
                        macro_table["%daterange%"] = strDateRange;

                        nRet = OutputExcelReport(
                            tableList,
                            strCfgFile,
                            macro_table,
                            strOutputFileName,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;

                        stop.SetProgressValue(i + 1);
                    }
                }
            }
            finally
            {
                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();

                EnableControls(true);
            }

            return;
        ERROR1:
            MessageBox.Show(this, strError);
        }


        ~~~
        当 CfgDlg 中没有选择 OI 元素写入，但 library.xml 中配置了 OI，这种情况要警告

        ~~~
        UHF 标签的 User Bank 规格也可以考虑从 TID 中的厂家代码和批次等信息推断

        ~~~
        探测 UHF 标签的 User Bank Capacity 的功能，当初始时标签的 EPC PC 中的 UMI 标志位为 false 时，
        就涉及到要主动改变 UMI 位为 true。需要记住最后完成探测后，要把 EPC 写回原来的值

        ~~~
        写入图书标签的时候如果遇到选择的标签原内容是读者类型；或者反之写入读者标签的时候如果遇到选择的标签原内容
        是图书类型，需要进行警告

        ~~~
        设计一种只读入 EPC 的模式，加快借书还书速度。
        方法是利用两阶段 update 的第一阶段信号。第二阶段增加 bytes 的信号可以设法省略。
        SendKey() 发送的字符串，里面 tou: 可以用 (unkown) 或者空缺。这样迫使软件用条码号形态规则判断这是一个什么类型的号码
        什么时候会缺乏 tou: 呢？如果是标签的 EPC 和 User Bank 明确都不存在 TypeOfUsage 元素，则默认为图书，这时候 tou: 是 “10”
        而明明标签存在 TypeOfUsage 元素(比如 EPC 中 OID Mask 标出来了)，但因为不能读出 User Bank 而得不到这个 TypeOfUsage 元素内容，此时 tou: 空缺，表示类型待定，也就是上面说的可以进一步根据号码的形态自动探测确定


        ~~~
        修改 EAS 以后，可以预测修改后的 UID 是什么，后面再来这个 UID 的更新消息可以主动吞掉一次。
        为了可靠，还可以加上一个这个吞掉的时效(比如半分钟)。
        和以往的根据 PII 来吞掉近期重复更新消息不同，这种做法是吞掉 UID 变化后的同 PII 消息

        ~~~
        CfgDlg 中用于测试的参数都标上红色，表示危险


        ~~~
        人脸识别命中多个，进行选择的对话框中，应可以点列标题排序
        最好再能增加一列显示人脸识别命中分数

~~~
合并到 ... 功能。
由于当前可能已经存在多条互相重复的记录，所以“合并到”功能应该有个参数允许这一次合并保存。
随着合并操作的进行，这一组互相重复的记录数量会逐渐减少，直到完全消灭合并现象

~~~
2024/5/19
MARC 格式转换的结果，也分完全正确和发生错误、有警告等三种状态。
在批处理 MARC 格式转换的时候，遇到错误的情况要报错。

系统管理窗的内核属性页，在修改了 dp2circulation_marc_verify.cs .fltx .cs.ref 和
dp2circulation_marc_convert.cs .fltx .cs.ref 文件以后，要自动从 AssemblyCache
中清掉相关的 Assembly。并且向所有种册窗发出通知消息，通知清除工具条上校验按钮下的相关菜单事项。

种册窗或者批处理进行校验、格式转换的时候，应可以按照如下顺序得到当前记录
的现有编目规则：
1) 书目库角色中的 cr:xxx 子参数定义的 xxx 部分。如果没有找到，则：
2) 当前 MARC 记录中的 998$c 子字段内容(注意核实一下 $c 以前没有被占用)。如果没有找到，则:
3) 根据选择的菜单，或者弹出对话框询问编目规则。

998 字段需要增加一个 $l 子字段，里面存储一个 GUID，用来横向关联不同编目规则的同一书目记录
(注意核实一下 $l 子字段以前没有被占用) ($o 也是一个备选的子字段名)

要区分配置文件不存在，和 actions.Count == 0 两种情况。前者无法进行校验，后者
校验的时候 action 为 ""

选择目标库对话框中的第一个栏目标题“验收目标库”字样应该修改为“格式转换目标库”，或者就叫“书目库”也行

在书目查询窗中批处理转换的过程中，需要为源记录和目标记录都加上 998$l 子字段，
关联这两条记录的同源关系。那么就需要为每一个浏览行，保留原来的浏览行，并且新增
一个浏览行。保留的行负责体现对 998$l 的新增；新增的浏览行体现新创建的新
编目规则的记录。

负责增添或者修改 998$l 的函数，应尽量不改变原有 $l 的位置。这样可以尽量
避免源书目记录 XML 发生变化。不发生变化就不用保存。

另外格式校验会可能会在书目记录中增添 998$c，让浏览行变为已修改状态。可以
考虑批处理前弹出对话框询问一下是否要进行这样的改变。(如果不改变就是单纯校验，
如果校验本身没有修改任何字段，记录就会处于未改变状态)

书目查询窗浏览框中处于尚未保存状态的记录，例如记录路径为 中文图书/?1
这样的，双击浏览行的时候，要报错说尚未保存，无法打开种册窗进行编辑。
或者将来增加一种可以直接编辑内存中记录的新功能。

种册窗中 Ctrl+Y 进行校验的时候，如果当前书目库的脚本中配置了多种编目规则，
并且当前记录看不出来是什么规则，要弹出对话框让选择一个打算校验的规则。
校验完成后，最好能自动为 MARC 记录中添加一个 998$c 记住编目规则。

种册窗保存 MARC 记录的时候，(自动校验) 可以自定义检查记录是否具备 998$c，如果不具备就
弹出对话框选择并增添一个 998$c，或者只是报错，等待操作人员自己去键盘输入。

~~~
导出读者记录 XML 到文件，文件中可以加一些注释，说明这个文件是备份的，
还是普通导出的。

导出开始前，如果是备份导出，警告数据文件中会包含 password 元素(Hash 以后的密码)
等敏感字段，对这样的备份文件要注意妥善管理保存。

~~~
批处理格式转换，开始对话框让选择目标书目库，后面要对每条记录检查它的 marc syntax
是否和这个目标书目库的 marc syntax 相容。(.cs 脚本中应当可以指定这个计划的目标 marc syntax
如果缺省，就表示和源记录 marc syntax 一致)

~~~
998$l 中的 ID 字符串，有没有办法发生得短一些？一个可选的办法，是利用源书目记录
的路径当作这个 ID。不过，可能容易引起误解。

~~~
格式转换时要对 crkey 查重，看看此前是不是已经有关联的目标编目规则的记录存在了。

~~~
997 的字符串生成规则中，要在末尾加一段 998$c。如果 998$c 不存在，则末尾
这一段新增的就不要加，连竖线也不要加，就和算法修改以前的上一版产生的字符串一样，
这样才能取得良好的兼容性(用不到 998$c 的图书馆用户的 997 查重字符串不会因为
dp2library 版本升级而发生变化，因而也就免去了升级后管理员启动重新生成 997 字段的麻烦)

~~~
格式转换生成 MARC 内容后冲掉另外一条记录中原有的 MARC，要注意保留原来 MARC
记录中的 856 字段。另外原来 XML 记录中的 dprms:file 元素也要得到保留

~~~
MARC 编辑器的背景，用淡色字体显示它的编目规则名称

~~~
内务系统管理窗“内核”属性页上传的 dp2circulation_marc_verify.cs 文件，
要在上传以前先统一把 encoding 改为 utf-8 才行

~~~
检查书目记录完整性的功能，要增加一个子功能，可以检查 856 中用到对象是否
完好无损。有损坏的要能出现报错。
另外，需要一个方便使用的，从操作日志中寻找和恢复对象内容的功能

~~~
TypoUtility 的 XmlToWord() 功能，要放在单独的线程中运行，避免冻结
界面线程。
XmlToWord() 功能中获得 https 图像文件的时候，要能通过回调函数显示
正在获取什么 URL。
XmlToWord() 功能可以显示执行的进度。进度可以用某一层处理 XML 元素的
进度来表示。

~~~
https://andrewlock.net/exporing-the-code-behind-ihttpclientfactory/#:~:text=To%20use%20the%20factory%2C%20and%20create%20an%20HttpClient%2C,use%20the%20default%20name%2C%20%22%22%20%28the%20empty%20string%29.

https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines

https://josef.codes/you-are-probably-still-using-httpclient-wrong-and-it-is-destabilizing-your-software/

~~~
书目查询窗的浏览列表中应允许选择两条记录进行右侧固定面板区对照显示。
可以用于查重的记录之间的比对观察。
另外可以选定两条记录，上下文菜单打开一个对照窗口进行显示。

可以选定多条记录，分别都装入一个新开的种册窗。不过，要限制最多条数，避免
内存爆掉。

~~~
系统管理窗“内核”属性页修改了一个 .cs 脚本以后，书目查询窗这里的格式转换
和校验功能似乎还是在使用以前 cache 的旧 .cs 脚本的内容。

~~~
书目查询窗编写利用 997 查重的 MarcQuery 脚本。成熟后可以上升为一次开发
功能。初步设想，是可以一边查重，一边留下发生了重复的浏览行，没有发生重复的
浏览行就自动移除了。

~~~
https://khalidabuhakmeh.com/how-to-write-a-dotnet-markdig-extension-for-markdown-processing

https://xoofx.github.io/blog/2016/06/13/implementing-a-markdown-processor-for-dotnet/

