1.0.0.86版

1) 新增册统计窗和书目统计窗

---

1.0.0.88版

2007/10/18

1) 书目检索窗可以使用__id途径进行记录索引号范围检索了。输入类似“1-10”这样的检索词。注意不支持逗号间隔的分段。这个功能需要最新版的dp2libraryws支持。

2) 书目检索窗新增导出“记录路径文件”功能。

3) 种册窗有一个错误：当利用“删除书目记录”按钮操作后，MARC编辑器和实体列表都会变为disabled状态，但当随后立即用“保存书目记录”按钮保存记录回数据库后，disabled状态不会变回enabled状态。这个错误已经改正。

4) 实体查询窗新增导出“记录路径文件”和“册条码号文件”功能。

5) 菜单“帮助/参数设置”所打开的“参数配置”对话框，增加了一个propertypage“检索”。里面有3个配置事项：书目检索窗最大命中条数、读者查询窗最大命中条数、实体查询窗最大命中条数，分别可以控制3种窗口的检索最大命中条数。

这些参数如果设置为-1，表示不限制。提供这些配置参数以前，原来3种窗口的缺省配置参数为1000,-1,-1。


---

1.0.0.89版

2007/10/19

1) 为书目检索窗、读者查询窗、实体查询窗的命中记录列表增加了鼠标左键点击栏目标题后排序的功能。

2) 为种册管理窗中的实体记录信息增加了<volume>元素，表示各册的卷号。为此，dp2libraryws图书馆应用服务器也进行了升级。

---

1.0.0.91版

2007/10/26

1) 为满足“借阅排行”统计方案的一些要求，针对OperLogStatisForm(宿主)进行了修改。

---

1.0.0.94版

2007/11/6

由于这个版本更换了数字签名证书，只能把以前的版本在控制面板中卸载后，才能安装新版本。

重新安装后，若干统计方案在dp2circulation中会丢失。这些统计方案可在下面这个地址找到，并重新导入：

http://dp2003.com/dp2bbs/article.aspx?board=@__2&id=205

1) 批修改册窗中，“文件驱动”page的“条码号文件名”旁增加了一个“...”按钮，用途是查找条码文件名。

2) 批修改册窗中，遇到条码为多条记录所用的情况，现在软件在装载这样的条码的对应记录时会报错。工作人员需要将条码重复使用情况排除后，才能利用批修改册窗对册记录进行修改。

3) 书目查询窗、实体查询窗、读者查询窗中，当正在装入浏览记录的时候关闭窗口，会报错。此错误已经被改正。

---

1.0.0.95

2007/11/12

1) 原来版本读者窗中调入空白工作单后然后保存，API SetReaderInfo()的strOldXml参数不为空，这个错误已经改正。

原来版本和dp2libraryws新版本配套使用会报错。

2) 原来版本读者窗中删除一条读者记录后，重新保存，API SetReaderInfo()的strAction参数值为"new"，不对，应该为"change"。这个错误已经改正。

原来版本和dp2libraryws新版本配套使用会报错。

---

1.0.0.96

2007/11/15

1) 为二次开发的宿主类BiblioStatis增加了成员

        public List<ItemInfo> ItemInfos

---

1.0.0.97

2007/11/21

1) 种册管理窗增加了“对象”tabpage。在这里可以增删改书目记录所属的资源对象。

---

1.0.0.98

2007/11/22

1) 原来的版本，读者查询窗中，无法将重复条码记录中后面的条装入读者窗。现在已经给浏览框中右鼠标键popupmenu增加了一个“根据记录路径装入到读者窗”命令，用这个命令可以把重复条码的记录中后面的条装入读者窗。

2) 原来的版本，读者窗中如果装入了重复条码的其中一条读者记录，用“删除”按钮无法删除。现在依然保留这个效果(一般删除的时候不是用记录路径进行删除，而是用条码进行删除，因此会出现删除不了并报警的情况)，但是增加了一个功能：按住CTRL键的同时点删除按钮，就可以根据该记录的路径来进行删除 -- 就可以删除重复条码的记录了。

不过删除的成功仍然需要一些前提条件：即将被删除的记录没有流通信息，即没有借还信息和违约交费信息才行。

---

1.0.0.102

2007/12/11

1) 种册管理窗中，MARC编辑器的CTRL+A功能，原来版本是从相应书目库的cfgs/dp2_autogen.cs和cfgs/dp2_autogen.cs.ref中获得C#脚本并执行，现在改为从相应书目库的cfgs/dp2circulation_marc_autogen.cs和cfgs/dp2circulation_marc_autogen.cs.ref中获得C#脚本并执行。并且脚本代码因为所涉及的部分类库功能调整而需要修改才能通过编译。

2) 增加流通凭条打印功能。可以打印读者的借、还、违约金情况。


~~~

        void menu_createBorrowListReport_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            string strUsedDateRange = this.MainForm.AppInfo.GetString("reportform",
    "borrowlist_daterange",
    "2013");

            string strDateRange = InputDlg.GetInput(
    this,
    "创建报表",
    "请指定时间范围: ",
    strUsedDateRange,
    this.MainForm.DefaultFont);
            if (strDateRange == null)
                return;

            this.MainForm.AppInfo.SetString("reportform",
                "borrowlist_daterange",
                strDateRange);

            // 输出文件目录
            FolderBrowserDialog dlg = new FolderBrowserDialog();

            dlg.Description = "请报表输出的目录:";
            dlg.RootFolder = Environment.SpecialFolder.MyComputer;
            dlg.SelectedPath = this.MainForm.AppInfo.GetString("reportform",
    "borrowlist_output_dir",
    "");

            if (dlg.ShowDialog() != DialogResult.OK)
                return;

            // 检查输出目录是否符合规则
            // 不能使用根目录
            string strRoot = Directory.GetDirectoryRoot(dlg.SelectedPath);
            if (PathUtil.IsEqual(strRoot, dlg.SelectedPath) == true)
            {
                strError = "报表输出目录 '" + dlg.SelectedPath + "' 不合法。不能是根目录";
                goto ERROR1;
            }

            DirectoryInfo di = new DirectoryInfo(dlg.SelectedPath);
            FileSystemInfo [] infos = di.GetFileSystemInfos();
            if (infos.Length > 0)
            {
                DialogResult temp_result = MessageBox.Show(this,
"输出目录  中已经存在内容。\r\n\r\n是否要清除里面的全部子目录和文件?",
"ReportForm",
MessageBoxButtons.YesNo,
MessageBoxIcon.Question,
MessageBoxDefaultButton.Button2);
                if (temp_result == System.Windows.Forms.DialogResult.Yes)
                {
                    // 清除目录中的全部内容
                    // 删除对象目录，然后重建
                    try
                    {
                        PathUtil.DeleteDirectory(dlg.SelectedPath);
                        PathUtil.CreateDirIfNeed(dlg.SelectedPath);
                    }
                    catch (Exception ex)
                    {
                        strError = "清除 输出目录 '" + dlg.SelectedPath + "' 内原有子目录和文件时发生错误： " + ex.Message;
                        goto ERROR1;
                    }
                }
            }

            this.MainForm.AppInfo.SetString("reportform",
    "borrowlist_output_dir",
    dlg.SelectedPath);

            string strOutputDir = dlg.SelectedPath;

            List<string> librarycodes = new List<string>();
            foreach (ListViewItem item in this.listView_libraryConfig.SelectedItems)
            {
                string strLibraryCode = ListViewUtil.GetItemText(item, 0);
                librarycodes.Add(strLibraryCode);
            }

            EnableControls(false);

            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在创建报表 ...");
            stop.BeginLoop();

            try
            {
                this._connectionString = GetOperlogConnectionString();  //  SQLiteUtil.GetConnectionString(this.MainForm.UserDir, "operlog.bin");
                // 创建报表阶段需要的附加索引
                nRet = OperLogLine.CreateAdditionalIndex(
                    this._connectionString,
                    out strError);
                if (nRet == -1)
                    goto ERROR1;



                foreach (string strLibraryCode in librarycodes)
                {
                    XmlNode nodeLibrary = this._cfg.GetLibraryNode(strLibraryCode);
                    if (nodeLibrary == null)
                    {
                        strError = "在配置文件中没有找到馆代码为 '" + strLibraryCode + "' 的 <library> 元素";
                        goto ERROR1;
                    }

                    string strCfgFile = "";
                    // 根据配置文件类型，找到配置文件名
                    nRet = FindCfgFileByType(nodeLibrary,
                        "131",
                        out strCfgFile,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;
                    if (nRet == 0)
                    {
                        strError = "当前分馆 '" + strLibraryCode + "' 没有配置 131 类型的配置文件";
                        goto ERROR1;
                    }

                    string strColumnSortStyle = GetColumnSortStyle(strCfgFile);
                    if (string.IsNullOrEmpty(strColumnSortStyle) == true)
                        strColumnSortStyle = "1:a";
                    else
                        strColumnSortStyle = SortColumnCollection.NormalToTable(strColumnSortStyle);


                    Hashtable macro_table = new Hashtable();
                    macro_table["%library%"] = strLibraryCode;

                    Table reader_table = null;

                    // 获得一个分馆内读者记录的证条码号和单位名称
                    nRet = GetAllReaderDepartments(
                            strLibraryCode,
                            ref reader_table,
                            out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    reader_table.Sort("1:a,-1:a");

                    stop.SetProgressRange(0, reader_table.Count);
                    for (int i = 0; i < reader_table.Count; i++)
                    {
                        Application.DoEvents();
                        if (stop != null && stop.State != 0)
                        {
                            strError = "用户中断...";
                            goto ERROR1;
                        }

                        Line line = reader_table[i];
                        string strReaderBarcode = line.Entry;
                        string strName = line.GetString(0);
                        string strDepartment = line.GetString(1);

                        string strDepartmentName = strDepartment.Replace(" ", "_");
                        if (string.IsNullOrEmpty(strDepartmentName) == true)
                            strDepartmentName = "其他部门";

                        string strOutputFileName = Path.Combine(strOutputDir,
                            strLibraryCode + "\\" + strDepartmentName + "\\" + strReaderBarcode + "_" + strName.Replace(" ", "")+ ".xlsx");

                        stop.SetMessage("正在创建报表文件 " + strOutputFileName + " " + (i + 1).ToString() + "/" + reader_table.Count.ToString() + " ...");

                        // 确保目录被创建
                        // PathUtil.CreateDirIfNeed(Path.GetDirectoryName(strOutputFileName));

                        Table tableList = null;
                        nRet = CreateReaderReport(
                            strLibraryCode,
                            strDateRange,
                            "131",
                            strReaderBarcode,
                            ref tableList,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;

                        tableList.Sort(strColumnSortStyle);  // "1:a" 按照借书时间排序

                        macro_table["%name%"] = strName;
                        macro_table["%department%"] = strDepartment;
                        macro_table["%readerbarcode%"] = strReaderBarcode;

                        macro_table["%linecount%"] = tableList.Count.ToString();
                        macro_table["%daterange%"] = strDateRange;

                        nRet = OutputExcelReport(
                            tableList,
                            strCfgFile,
                            macro_table,
                            strOutputFileName,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;

                        stop.SetProgressValue(i + 1);
                    }
                }
            }
            finally
            {
                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();

                EnableControls(true);
            }

            return;
        ERROR1:
            MessageBox.Show(this, strError);
        }


        ~~~
        当 CfgDlg 中没有选择 OI 元素写入，但 library.xml 中配置了 OI，这种情况要警告

        ~~~
        UHF 标签的 User Bank 规格也可以考虑从 TID 中的厂家代码和批次等信息推断

        ~~~
        探测 UHF 标签的 User Bank Capacity 的功能，当初始时标签的 EPC PC 中的 UMI 标志位为 false 时，
        就涉及到要主动改变 UMI 位为 true。需要记住最后完成探测后，要把 EPC 写回原来的值

        ~~~
        写入图书标签的时候如果遇到选择的标签原内容是读者类型；或者反之写入读者标签的时候如果遇到选择的标签原内容
        是图书类型，需要进行警告

        ~~~
        设计一种只读入 EPC 的模式，加快借书还书速度。
        方法是利用两阶段 update 的第一阶段信号。第二阶段增加 bytes 的信号可以设法省略。
        SendKey() 发送的字符串，里面 tou: 可以用 (unkown) 或者空缺。这样迫使软件用条码号形态规则判断这是一个什么类型的号码
        什么时候会缺乏 tou: 呢？如果是标签的 EPC 和 User Bank 明确都不存在 TypeOfUsage 元素，则默认为图书，这时候 tou: 是 “10”
        而明明标签存在 TypeOfUsage 元素(比如 EPC 中 OID Mask 标出来了)，但因为不能读出 User Bank 而得不到这个 TypeOfUsage 元素内容，此时 tou: 空缺，表示类型待定，也就是上面说的可以进一步根据号码的形态自动探测确定


        ~~~
        修改 EAS 以后，可以预测修改后的 UID 是什么，后面再来这个 UID 的更新消息可以主动吞掉一次。
        为了可靠，还可以加上一个这个吞掉的时效(比如半分钟)。
        和以往的根据 PII 来吞掉近期重复更新消息不同，这种做法是吞掉 UID 变化后的同 PII 消息

        ~~~
        CfgDlg 中用于测试的参数都标上红色，表示危险


        ~~~
        人脸识别命中多个，进行选择的对话框中，应可以点列标题排序
        最好再能增加一列显示人脸识别命中分数

~~~
合并到 ... 功能。
由于当前可能已经存在多条互相重复的记录，所以“合并到”功能应该有个参数允许这一次合并保存。
随着合并操作的进行，这一组互相重复的记录数量会逐渐减少，直到完全消灭合并现象

~~~
2024/5/19
MARC 格式转换的结果，也分完全正确和发生错误、有警告等三种状态。
在批处理 MARC 格式转换的时候，遇到错误的情况要报错。

系统管理窗的内核属性页，在修改了 dp2circulation_marc_verify.cs .fltx .cs.ref 和
dp2circulation_marc_convert.cs .fltx .cs.ref 文件以后，要自动从 AssemblyCache
中清掉相关的 Assembly。并且向所有种册窗发出通知消息，通知清除工具条上校验按钮下的相关菜单事项。

种册窗或者批处理进行校验、格式转换的时候，应可以按照如下顺序得到当前记录
的现有编目规则：
1) 书目库角色中的 cr:xxx 子参数定义的 xxx 部分。如果没有找到，则：
2) 当前 MARC 记录中的 998$c 子字段内容(注意核实一下 $c 以前没有被占用)。如果没有找到，则:
3) 根据选择的菜单，或者弹出对话框询问编目规则。

998 字段需要增加一个 $l 子字段，里面存储一个 GUID，用来横向关联不同编目规则的同一书目记录
(注意核实一下 $l 子字段以前没有被占用) ($o 也是一个备选的子字段名)

要区分配置文件不存在，和 actions.Count == 0 两种情况。前者无法进行校验，后者
校验的时候 action 为 ""

选择目标库对话框中的第一个栏目标题“验收目标库”字样应该修改为“格式转换目标库”，或者就叫“书目库”也行

在书目查询窗中批处理转换的过程中，需要为源记录和目标记录都加上 998$l 子字段，
关联这两条记录的同源关系。那么就需要为每一个浏览行，保留原来的浏览行，并且新增
一个浏览行。保留的行负责体现对 998$l 的新增；新增的浏览行体现新创建的新
编目规则的记录。

负责增添或者修改 998$l 的函数，应尽量不改变原有 $l 的位置。这样可以尽量
避免源书目记录 XML 发生变化。不发生变化就不用保存。

另外格式校验会可能会在书目记录中增添 998$c，让浏览行变为已修改状态。可以
考虑批处理前弹出对话框询问一下是否要进行这样的改变。(如果不改变就是单纯校验，
如果校验本身没有修改任何字段，记录就会处于未改变状态)

书目查询窗浏览框中处于尚未保存状态的记录，例如记录路径为 中文图书/?1
这样的，双击浏览行的时候，要报错说尚未保存，无法打开种册窗进行编辑。
或者将来增加一种可以直接编辑内存中记录的新功能。

种册窗中 Ctrl+Y 进行校验的时候，如果当前书目库的脚本中配置了多种编目规则，
并且当前记录看不出来是什么规则，要弹出对话框让选择一个打算校验的规则。
校验完成后，最好能自动为 MARC 记录中添加一个 998$c 记住编目规则。

种册窗保存 MARC 记录的时候，(自动校验) 可以自定义检查记录是否具备 998$c，如果不具备就
弹出对话框选择并增添一个 998$c，或者只是报错，等待操作人员自己去键盘输入。

~~~
导出读者记录 XML 到文件，文件中可以加一些注释，说明这个文件是备份的，
还是普通导出的。

导出开始前，如果是备份导出，警告数据文件中会包含 password 元素(Hash 以后的密码)
等敏感字段，对这样的备份文件要注意妥善管理保存。

~~~
批处理格式转换，开始对话框让选择目标书目库，后面要对每条记录检查它的 marc syntax
是否和这个目标书目库的 marc syntax 相容。(.cs 脚本中应当可以指定这个计划的目标 marc syntax
如果缺省，就表示和源记录 marc syntax 一致)

~~~
998$l 中的 ID 字符串，有没有办法发生得短一些？一个可选的办法，是利用源书目记录
的路径当作这个 ID。不过，可能容易引起误解。

~~~
格式转换时要对 crkey 查重，看看此前是不是已经有关联的目标编目规则的记录存在了。

~~~
997 的字符串生成规则中，要在末尾加一段 998$c。如果 998$c 不存在，则末尾
这一段新增的就不要加，连竖线也不要加，就和算法修改以前的上一版产生的字符串一样，
这样才能取得良好的兼容性(用不到 998$c 的图书馆用户的 997 查重字符串不会因为
dp2library 版本升级而发生变化，因而也就免去了升级后管理员启动重新生成 997 字段的麻烦)

~~~
格式转换生成 MARC 内容后冲掉另外一条记录中原有的 MARC，要注意保留原来 MARC
记录中的 856 字段。另外原来 XML 记录中的 dprms:file 元素也要得到保留

~~~
MARC 编辑器的背景，用淡色字体显示它的编目规则名称

~~~
内务系统管理窗“内核”属性页上传的 dp2circulation_marc_verify.cs 文件，
要在上传以前先统一把 encoding 改为 utf-8 才行

~~~
检查书目记录完整性的功能，要增加一个子功能，可以检查 856 中用到对象是否
完好无损。有损坏的要能出现报错。
另外，需要一个方便使用的，从操作日志中寻找和恢复对象内容的功能

~~~
TypoUtility 的 XmlToWord() 功能，要放在单独的线程中运行，避免冻结
界面线程。
XmlToWord() 功能中获得 https 图像文件的时候，要能通过回调函数显示
正在获取什么 URL。
XmlToWord() 功能可以显示执行的进度。进度可以用某一层处理 XML 元素的
进度来表示。

~~~
https://andrewlock.net/exporing-the-code-behind-ihttpclientfactory/#:~:text=To%20use%20the%20factory%2C%20and%20create%20an%20HttpClient%2C,use%20the%20default%20name%2C%20%22%22%20%28the%20empty%20string%29.

https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines

https://josef.codes/you-are-probably-still-using-httpclient-wrong-and-it-is-destabilizing-your-software/

~~~
书目查询窗的浏览列表中应允许选择两条记录进行右侧固定面板区对照显示。
可以用于查重的记录之间的比对观察。
另外可以选定两条记录，上下文菜单打开一个对照窗口进行显示。

可以选定多条记录，分别都装入一个新开的种册窗。不过，要限制最多条数，避免
内存爆掉。

~~~
系统管理窗“内核”属性页修改了一个 .cs 脚本以后，书目查询窗这里的格式转换
和校验功能似乎还是在使用以前 cache 的旧 .cs 脚本的内容。

~~~
书目查询窗编写利用 997 查重的 MarcQuery 脚本。成熟后可以上升为一次开发
功能。初步设想，是可以一边查重，一边留下发生了重复的浏览行，没有发生重复的
浏览行就自动移除了。

~~~
https://khalidabuhakmeh.com/how-to-write-a-dotnet-markdig-extension-for-markdown-processing

https://xoofx.github.io/blog/2016/06/13/implementing-a-markdown-processor-for-dotnet/

~~~
需要一个支持多行文本输入的 InputDlg.GetInput() 函数

~~~
导出 MARC 文件时，按照子字段名删除后，可能会产生一些内容为空的字段，这样的空字段也要随后删除
新建 ComboBox 下拉事项的时候，刚新建出来的代码内容为空。用户可以从此开始输入内容


~~~

override void OnPreviewKeyDown()
可以预览到各种击键，即便一个控件它通过响应 GetDlgCode 消息声明自己不想获得某些
键，也能预览到。

父窗口通过 GetDlgCode 消息询问一个控件，知道控件的类型。比如有些控件
希望父窗口直接截获方向键，实现多个控件之间的焦点转移，这是对话框的一种
常见功能。

~~~
https://www.c-sharpcorner.com/UploadFile/4aac15/positioning-caret-in-textbox/
https://www.codeproject.com/Tips/794589/NET-Get-correct-caret-position-from-TextBox-contro

~~~
在已经有字段块定义的情况下，点 Home 到块的第一行，点 End 到块的最后一行

普通输入情况下，点 Ctrl+Home 到第一行，点 Ctrl+End 到最后一行

上下方向键时候，要保持对出发点 x 坐标的张力，一直尝试模拟点击这个位置。

允许 textbox 输入的一行，背景要显示为虚框的 focus 状态

书目查询窗刚打开的时候，输入焦点应该定位到检索词 textbox 上面

MarcEditor 中鼠标滚轮不起作用

~~~~
https://stackoverflow.com/questions/3938998/wrapping-text-in-a-rich-textbox-but-not-word-wrapping-it/3955553#3955553

https://github.com/dahall/Vanara/blob/bc3d5fa7ea14084755558237f2c242df4d75cbdf/PInvoke/Usp10/Usp10.cs#L213

https://github.com/LayoutFarm/Typography

https://learn.microsoft.com/en-us/windows/win32/inputdev/using-keyboard-input

~~~
Ctrl+A 时如果发现没有可用的命令，则 Beep() 响一声，输入焦点依然在 MarcEditor 上。
此时编目员可以设法用另外的热键切换到数据加工菜单，用键盘选择命令进行。或者有一个热键可以 Popup 数据加工菜单，进行选择调用

需要一个切换到 MARC 编辑器的热键。Ctrl+1。数据加工为 Ctrl+2。

~~~
MARC 编辑器中任意键可以自动消掉 FloatingMessage 窗口，并且这个键本身的
作用不受影响

~~~
“组合”属性页中增加“复制单列”命令。
所选的 match_style 在内务退出时应能自动保存，下次启动能恢复上次的选择。
增加选择检索目标库的机制。
增加“页码”等非检索点列。

~~~
从 Z39.50 服务器获得一条记录，装入种册窗，复制保存到一个书目库，
中间遇到强制校验出错。然后种册窗的路径自动变为“xxxx/?”，此时再复制
就报错说，可以直接用保存功能，但保存按钮为 disabled 状态。
建议失败后，路径依然恢复到最初为空的状态，这样方便再次复制保存

~~~
从 dp2circulation 的系统管理窗修改一个 keys 配置文件后，发现无论如何
从 dp2circulation 的书目查询窗中都看不到新增定义的检索途径，只能
把 dp2library 模块重启才行。希望可以在 keys 配置文件修改后，dp2circulation
能及时感知到改变后的检索途径

~~~
title 用于主键检索只允许有一列。但用于过滤，可以有多列 title。
这些多列之间依然是 and 关系。不过，注意 title 需要对应于 225$a 200$e
等多个字段。这些信息从哪儿获取？理论上是从 keys 配置文件中。或者约定俗成(例如页码字段)

~~~
https://www.csdndocs.com/article/9326767
Winform 多MDI窗体关闭时，无法访问已释放的对象对象名:“Icon”

https://www.csdndocs.com/article/1311186

~~~
https://www.cnblogs.com/ghbjimmy/articles/3635825.html
C#Winform频繁刷新导致界面闪烁解决方法

~~~
增加一个种次号库检索管理窗。用 DataGridView 来显示检索结果，
可以修改记录内容，然后保存修改。
可以创建和删除记录。
检索词可以前方一致的检索。

~~~
书目查询窗的多行检索界面，增加功能: 检索未命中的检索词可以进入一个文本文件。
组合检索应能处理 Z39.50 服务器和共享检索。


~~~
等用户服务器 dp2library 升级后，把 dp2circulation 中创建的 998$u 时间改为 s 格式。
原有的 u 格式应是 UTC 时间，东八区看起来非常吃力。

GetTimeDialog() 尽量改为 .sString，避免用以前的 .uString，
但要做好回归测试，验证 .sString 获得的时间字符串检索功能正常

~~~
种册窗保存 MARC 记录修改后，要通知书目查询窗，把 biblio_table 中的
相关对象删除。同样，书目查询窗修改保存记录后，要通知种册窗这条记录
发生了变化，是否重新加载？

~~~
MarcEditor 在内容区粘贴一段文字(使用小 edit 上的上下文菜单 paste 命令)，
可能导致内容整体超出小 textbox 高度
容纳范围，应及时调整 textbox 高度


~~~
安装包 marcdef 文件中 998 的 DefaultValue 要去掉
导出 MARC 文件功能，各个属性页中选择的关键参数，要在真正执行前
弹出一个确认对话框，确认一下，然后再正式开始处理。
比如脚本的选择，还有是否创建 905 906 字段等等，都是很关键的参数，
会影响到导出数据的内容

~~~
种册窗复制保存以后，焦点从 MARC 编辑器丢失了

~~~
dp2installer 升级后，是否会强制刷新 dp2library 数据目录中
templates 子目录中的文件，需要研究一下代码。

~~~
菜单“删除当前字段”功能没有执行

~~~
Ctrl+A 出现的小菜单中，应该有一项列出所有命令(包括当前不是蓝色背景的那些命令)

~~~
发出检索式，并要求每个检索词的名中结果，都符加一个 tag，这样便于最后
把命中结果和 tag 对应。特别是，知道哪些检索词没有命中。

~~~
导出 ISO2709 支持加入回车换行符

~~~
批检索 API 中途如果发现命中记录数过多，无法全部返回，
有权只返回前面部分检索词的命中结果。
但注意应该完整返回每个检索词的结果。

如果仅仅一个检索词就返回太多，超过包尺寸的限制，则此时返回 -1

~~~
检索词提交 BatchSearch() API 的时候，里面可以包含特殊的分割字符，
表示要将检索词进行试探检索。试探检索并不是 OR 算法，而是比 OR 更优化
的一种算法，当切割后的某个检索命中后就不再检索其它检索词
这个特殊字符用什么字符好呢？可以用 ^

~~~
过滤检索完成后，显示一下总耗费时间。

~~~
检索式列表中，检索词只有一栏时，选择检索途径的同时就自动勾选“检索键”

~~~
6307 行检索词。
原有 SearchBiblio() 方式耗费的时间: 15:10:27-16:14:07
BatchSearch() 方式耗费的时间: 18:58:48-19:51:50 21:16:55-22:14:18

release 版 22:52:08-23:48:01

~~~
检索词为空的跳过检索。可以在操作历史属性页提示出现了空格检索词。

~~~
https://testbook.com/objective-questions/mcq-on-standards-of-bibliographic-record-formats-descri--64f9c0bc4bcb7c7e344965a3

~~~
种册窗保存记录的时候，如果 dp2kernel 检索点创建失败，但目前 record 记录已经创建成功。
这样会令人迷惑。建议改进为创建检索点失败时，也把 record 记录删除。但尾号已经推动了，不好退回去了。
如果暂时不改进，最好在报错提示中说“虽然 ... 失败，但元数据记录已经创建成功”

keys 配置文件修改后，最好自动刷新一次书目查询窗的检索途径列表

~~~
提供一种管理命令，可以重新 InitialKdbs()。用于 dp2rms 等工具修改了 keys 配置文件之后

~~~
批检索出现通讯中断的时候，要能自动重试处理

~~~~
Windows 7 32bit 2G
https://jingyan.baidu.com/article/9158e00042c4b4a255122872.html

~~~
组合检索的表格，应该允许新增一行、一列。删除一行、一列。
移除所有行。也就是清除。分为，包括列标题，保留列标题。

~~~
https://xmanyou.com/how-to-enable-dns-over-https-on-windows/

~~~
SetBiblioInfo() API 考虑增加一个参数 comment，记载前端遇到时间戳冲突
时强行保存的情况

~~~
把接口 .exe 程序拷贝到 dp2library 的程序文件夹。
(这里有个问题，就是当 dp2installer 升级 dp2library 模块的时候，程序文件夹
里面的 .exe 程序可能丢失。那这样就需要考虑把 .exe 放到数据文件夹中？不过放到
数据文件夹里面一个问题就是，用户可以上传任意 .exe 到这里，会有一定的安全性隐患。
还有一个办法就是放到 c:\ 下面一个固定位置，这里用户无法上传覆盖到这里)


library.xml 中根元素下增加：
1) 测试、从 test.xml 文件中得到数据：
    <patronReplication exePath="!copy %datadir%/patronReplication/test.xml" patronDbName="同步读者" idElementName="qywx" idFromName="企业微信" />
2) 正式：
    <patronReplication exePath="%bindir%/zgyPatronReplication.exe" patronDbName="同步读者" idElementName="qywx" idFromName="企业微信" />



(patronReplication/@idFromName)
            // patronReplication/@idFromName 一般可以缺省。
            // 如果缺省，表示自动从 idElementName 推断 ID 检索途径的名字。对于系统标准支持的 barcode 和 cardNumber 元素，可以自动推断出来
            // 但如果 idElementName 是一个自定义的元素名时，无法自动推断，则需要明确定义 patronReplication/@idFromName 属性值才行。

library.xml 中 circulation 元素内增加属性:
    patronReplicationFields="qywx" 
    patronAdditionalFields="qywx"
    acceptBlankReaderBarcode="true" (注: 如果为 false，则同步的时候会报错说创建记录不允许证条码号为空)

library.xml 中 monitors 元素下添加:
        <patronReplication startTime="23:00" />
注意 patronReplication 元素名里面没有 Monitor 字样。

为所有读者库增配一个“企业微信”检索点：
keys 文件片段:
	<key>
		<xpath>*/qywx</xpath>
		<from>qywx</from>
		<table ref="qywx" />
	</key>
	<table name="qywx" id="20">
		<convert>
			<string style="upper,split" />
		</convert>
		<convertquery>
			<string style="upper" />
		</convertquery>
		<caption lang="zh-CN">企业微信</caption>
		<caption lang="en">Qiye Wexin</caption>
	</table>

为所有读者库的 browse 配置文件增加一列 qywx:
  <col title="企业微信">
    <xpath>*/qywx</xpath>
  </col>


dp2library 中读者同步模块要设计一种语法，表示如果以前不存在这条记录，则某个元素采用缺省值什么什么。
比如 <readerType dprms:default>普通</readerType>

由于用户单位已经有了大概两个读者库，首先需要用企业微信里面获得的一个 .xml
文件，去合并匹配现有的读者记录，为这些读者记录加入 qywx 元素。注意此前
要在 library.xml 暂时删除 patronReplication 元素，禁用读者同步功能。

(合并可以用读者查询窗的从 Excel 文件合并功能。Excel 文件从何而来？可以用企业
微信里面获得的 .xml 文件，先用 dp2batch 导入一个临时的读者库，然后用内务的
读者查询窗检索出这些记录，在浏览列表中全选导出到一个 Excel 文件。然后对 Excel 
文件删除大部分列，只留下 qywx name department 这几列。合并时候的 key 要用 name 列。
之所以包含 department 列，是因为在合并过程中，弹出对话框选择命中多条读者记录
情形时，需要看到 department 列有助于进行选择)

注: 上述临时读者库的 browse 文件要修改，增加 qywx 列。不然导出到 Excel 时就会缺这一列。
注: 将来，从 Excel 导入合并到读者库的功能，要增加从(Windows 剪贴板中的) tabbed text 粘贴过来的功能

合并完成后，然后在 library.xml 启用 patronReplication 元素。

library.xml 通过 monitors 元素，设置好读者同步的每日时刻。避免过分频繁地进行每日同步。
内务的批处理任务窗依然可以临时触发读者同步任务。

将 library.xml 中 patronReplication 以及其它重要配置参数的配置方法，写入
从卡中心获取数据的 .exe 源代码的注释中。

关于读者库的多库安排(基于同步策略的考量)：

一般原有的读者库保留不变。为了同步需要新创建一个名为“同步读者”的读者库，并在 patronReplication/@patronDbName 中使用这个读者库名。
这样，当 dp2library 进行同步的时候，来自卡中心的读者记录，先对所有读者库按照 ID 字段进行检索，
如果匹配上，则更新匹配上的这条记录，注意这条记录可能在原有的读者库中。如果没有匹配上，
则会在“同步读者”库中新增一条读者记录。
当卡中心的记录发生删除的时候，dp2library 同步的时候，会尝试从“同步读者”库中标记删除
对应的读者记录。注意，并不会从原有的读者库中去标记删除(虽然明显可以匹配的)记录。
这可以理解成，原有的读者库，这种身份，保护了里面的读者记录免受标记删除。

另一个不常见的方案，是利用原有的唯一的读者库，在 patronReplication/@patronDbName 中使用这个读者库名，
这样，dp2library 同步的时候，会把读者库中的所有记录和来自卡中心的记录进行集合运算，读者库中那些
多于卡中心的读者记录，会被标记删除。也就是说，读者库里面的记录没有上述免受标记删除的待遇了。
不过，记录被标记删除也不一定是不好的事情。
遇到标记删除的记录，可以这样处理：如果想恢复这条记录的可用状态(为啥？...)，可尝试找到这条读者记录重复了的其它读者记录，
如果找到了，把这条记录的 qywx 元素内容转移到被标记删除的、打算继续使用的记录中。然后把被转移的记录手动操作一下物理删除。
注: "如果想恢复这条记录的可用状态"，动机可能是因为这条记录使用时间很长，挂着以前的借阅历史。这条记录比后来同步自动建立起来的记录更有价值。

建议建立模拟环境，把两种策略都尝试验证一下。以用户单位角度，评估一下效果优劣。


~~~~
move 书目记录
如果当前账户不具备针对目标库的 read 权限，则在获得 ..._autogen.cs 配置文件
的阶段会报错说权限不够。
中文图书/1 --> 测试/?
中文图书:getbiblioinfo=*|setbiblioinfo=


如果当前账户具备源库和目标库的读权限，但不具备写权限 
中文图书/1 --> 测试/?
中文图书:getbiblioinfo=*|setbiblioinfo=;测试:getbiblioinfo=*|setbiblioinfo=
当前用户 'supervisor'  不具备 针对数据库 '测试' 执行 setbiblioinfo new 操作的存取权限


中文图书/1 --> 测试/1
中文图书:getbiblioinfo=*|setbiblioinfo=;测试:getbiblioinfo=*|setbiblioinfo=
当前用户 'supervisor'  不具备 针对数据库 '测试' 执行 setbiblioinfo change 操作的存取权限

~~~
导出到 ISO2709 文件的时候，可以尝试再从 ISO2709 转换回到机内格式，然后和导出前的内容对比，
如果发现不一致，就知道到处过程发生了字符损失，这时候要出现警告信息，提醒用户注意。

~~~
检索的时候，如果使用的是中间一致或者后方一致的匹配方式，并且检索第一阶段持续的时间较长，
应自动出现一种浮动的提示，提醒操作者，中间一致或者后方一致的检索速度较慢，请耐心等待，
或者可以按停止按钮中断检索。

~~~
文件 D:\xxx.iso 内的数据已经成功导入下列数据库:

net.pipe://localhost/dp2kernel/mysql/?中文图书

共导入记录 1085041 条。

总共耗费时间: 01:48:39.9982953

~~~
https://www.howtogeek.com/28609/how-can-i-tell-what-is-listening-on-a-tcpip-port-in-windows/

~~~
dp2kernel 的错误日志里面需要把 SQL 并发使用的通道数超过一定数额的情况记载下来，便于
事后分析。

~~~
https://dba.stackexchange.com/questions/9039/sudden-mysql-error-unable-to-connect-to-any-of-the-mysql-hosts

ISSUE #1 : Connection Errors

Once mysql has racked up enough connection errors, the host blocks all IPs until you do one of two things:

$ service mysql restart
mysql> FLUSH HOSTS;
According to MySQL Documentation on FLUSH HOSTS;

HOSTS

empties the host cache tables. You should flush the host tables if some of your hosts change IP address or if you get the error message Host 'host_name' is blocked. When more than max_connect_errors errors occur successively for a given host while connecting to the MySQL server, MySQL assumes that something is wrong and blocks the host from further connection requests. Flushing the host tables enables further connection attempts from the host. See Section C.5.2.6, “Host 'host_name' is blocked”. You can start mysqld with --max_connect_errors=999999999 to avoid this error message.

Try bumping up max_connect_errors (default is 10) to some obnoxiously high number, like 999999999 (about 1 billion), in /etc/my.cnf as follows:

[mysqld]
max-connect-errors=999999999
You will then just restar mysql. To put this new setting in place without restarting, just run this command in the mysql client:

mysql> SET GLOBAL max_connect_errors = 999999999;

~~~
组合检索的结果保存到 Excel 文件时，最好有一列显示命中结果。可以是书目记录记录路径和题名。

~~~
https://www.c-sharpcorner.com/blogs/auto-detecting-image-type-and-extension-from-byte-in-c-sharp

    // https://www.c-sharpcorner.com/blogs/auto-detecting-image-type-and-extension-from-byte-in-c-sharp
    public static class PictureHelper
    {
        // some magic bytes for the most important image formats, see Wikipedia for more
        static readonly List<byte> jpg = new List<byte> { 0xFF, 0xD8 };
        static readonly List<byte> bmp = new List<byte> { 0x42, 0x4D };
        static readonly List<byte> gif = new List<byte> { 0x47, 0x49, 0x46 };
        static readonly List<byte> png = new List<byte> { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A };
        static readonly List<byte> svg_xml_small = new List<byte> { 0x3C, 0x3F, 0x78, 0x6D, 0x6C }; // "<?xml"
        static readonly List<byte> svg_xml_capital = new List<byte> { 0x3C, 0x3F, 0x58, 0x4D, 0x4C }; // "<?XML"
        static readonly List<byte> svg_small = new List<byte> { 0x3C, 0x73, 0x76, 0x67 }; // "<svg"
        static readonly List<byte> svg_capital = new List<byte> { 0x3C, 0x53, 0x56, 0x47 }; // "<SVG"
        static readonly List<byte> intel_tiff = new List<byte> { 0x49, 0x49, 0x2A, 0x00 };
        static readonly List<byte> motorola_tiff = new List<byte> { 0x4D, 0x4D, 0x00, 0x2A };

        static readonly List<(List<byte> magic, string extension)> imageFormats = new List<(List<byte> magic, string extension)>()
    {
        (jpg, "jpg"),
        (bmp, "bmp"),
        (gif, "gif"),
        (png, "png"),
        (svg_small, "svg"),
        (svg_capital, "svg"),
        (intel_tiff,"tif"),
        (motorola_tiff, "tif"),
        (svg_xml_small, "svg"),
        (svg_xml_capital, "svg")
    };

        public static string TryGetExtension(Byte[] array)
        {
            // check for simple formats first
            foreach (var imageFormat in imageFormats)
            {
                if (array.IsImage(imageFormat.magic))
                {
                    if (imageFormat.magic != svg_xml_small && imageFormat.magic != svg_xml_capital)
                        return imageFormat.extension;

                    // special handling for SVGs starting with XML tag
                    int readCount = imageFormat.magic.Count; // skip XML tag
                    int maxReadCount = 1024;

                    do
                    {
                        if (array.IsImage(svg_small, readCount) || array.IsImage(svg_capital, readCount))
                        {
                            return imageFormat.extension;
                        }
                        readCount++;
                    }
                    while (readCount < maxReadCount && readCount < array.Length - 1);

                    return null;
                }
            }
            return null;
        }

        private static bool IsImage(this Byte[] array, List<byte> comparer, int offset = 0)
        {
            int arrayIndex = offset;
            foreach (byte c in comparer)
            {
                if (arrayIndex > array.Length - 1 || array[arrayIndex] != c)
                    return false;
                ++arrayIndex;
            }
            return true;
        }
    }


~~~
普通书目记录用 GetRes() API 获得的时候，style 中包含 ,gzip 还没有支持

~~~
2024/12/31
RfidCenter 改进：

在搜索读写器 XML 元数据的时候，当 antenna_count 元素内容为 0 的时候，需要进一步
寻找 cfg_antenna 元素的 antenna_cnt 属性
      <cfg_antenna auto_check='true' antenna_cnt='36'/>


~~~

注意 sub_id 属性：
      <sub_id>680601</sub_id>
提供了多个驱动 ID 映射到同一段 XML 元数据的可能。
