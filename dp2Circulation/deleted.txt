        // 提交所有保存请求
        // parameters:
        //      strStyle    风格。displaysuccess 显示最后的成功消息在框架窗口的状态条 verifydata 发送校验记录的消息(注意是否校验还要取决于配置状态)
        //                  searchdup 虽然对本函数没有作用，但是可以传递到下级函数SaveBiblioToDatabase()
        // return:
        //      -1  有错。此时不排除有些信息保存成功。
        //      0   成功。
        /// <summary>
        /// 全部保存
        /// </summary>
        /// <param name="strStyle">保存方式。由 displaysuccess / verifydata / searchdup 之一或者逗号间隔组合而成。displaysuccess 显示最后的成功消息在框架窗口的状态条; verifydata 保存成功后发送校验记录的消息(注意是否校验还要取决于配置状态); searchdup 保存成功后发送查重消息</param>
        /// <returns>-1: 有错。此时不排除有些信息保存成功。0: 成功。</returns>
        public int DoSaveAll(string strStyle = "displaysuccess,verifydata,searchdup")
        {
            bool bBiblioSaved = false;
            int nRet = 0;
            string strText = "";
            int nErrorCount = 0;

            bool bDisplaySuccess = StringUtil.IsInList("displaysuccess", strStyle);
            bool bVerifyData = StringUtil.IsInList("verifydata", strStyle);
            // bool bForceVerifyData = StringUtil.IsInList("forceverifydata", strStyle);

            bool bVerified = false;

            if (this.m_verifyViewer != null)
                this.m_verifyViewer.Clear();

            string strHtml = "";

            LibraryChannel channel = this.GetChannel();
            channel.Timeout = new TimeSpan(0, 5, 0);    // 保存大量册记录时可能会耗时长一点

            Progress.OnStop += new StopEventHandler(this.DoStop);
            Progress.Initial("正在保存记录 ...");
            Progress.BeginLoop();

            this.ShowMessage("正在保存记录 ...");
            try
            {
                if (this.BiblioChanged == true
                    || Global.IsAppendRecPath(this.BiblioRecPath) == true
                    || this.m_bDeletedMode == true /* 2011/11/8 */)
                {
                    // 2014/7/3
                    if (bVerifyData == true
    && this.ForceVerifyData == true)
                    {
                        GenerateDataEventArgs e1 = new GenerateDataEventArgs();
                        e1.FocusedControl = this.m_marcEditor;

                        // 0: 没有发现校验错误; 1: 发现校验警告; 2: 发现校验错误
                        nRet = this.VerifyData(this, e1, true);
                        if (nRet == 2)
                        {
                            MessageBox.Show(this, "MARC 记录经校验发现有错，被拒绝保存。请修改 MARC 记录后重新保存");
                            return -1;
                        }

                        bVerified = true;
                    }

                    // 保存书目记录到数据库
                    // return:
                    //      -1  出错
                    //      0   没有保存
                    //      1   已经保存
                    nRet = SaveBiblioToDatabase(
                        channel,
                        true,
                        out strHtml,
                        strStyle);
                    if (nRet == 1)
                    {
                        bBiblioSaved = true;
                        strText += "书目信息";
                    }
                    if (nRet == -1)
                    {
                        nErrorCount++;
                    }
                }

                bool bOrdersSaved = false;
                // 提交订购保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.orderControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bOrdersSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "采购信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;

                    // 2013/1/18
                    // 如果订购信息保存不成功，则不要继续保存后面的其他信息。这主要是为了订购验收环节考虑，避免在订购信息保存失败的情况下继续保存验收所创建的新的册信息
                    return -1;
                }

                bool bIssuesSaved = false;
                bool bIssueError = false;
                // 提交期保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.issueControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bIssuesSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "期信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;
                    bIssueError = true;

                    // 2013/1/18
                    // 如果期信息保存不成功，则不要继续保存后面的其他信息。这主要是为了期刊验收环节考虑，避免在期信息保存失败的情况下继续保存验收所创建的新的册信息
                    return -1;
                }

                bool bEntitiesSaved = false;

                // 注：在期刊记到后，如果期信息保存不成功，则不保存册信息。以免发生不一致
                if (bIssueError == false)
                {
                    // 提交实体保存请求
                    // return:
                    //      -1  出错
                    //      0   没有必要保存
                    //      1   保存成功
                    nRet = this.entityControl1.DoSaveItems(channel);
                    if (nRet == 1)
                    {
                        bEntitiesSaved = true;
                        if (strText != "")
                            strText += " ";
                        strText += "册信息";
                    }
                    if (nRet == -1)
                    {
                        nErrorCount++;
                    }
                }

                bool bCommentsSaved = false;
                // 提交评注保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.commentControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bCommentsSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "评注信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;
                }

                bool bObjectSaved = false;
                string strError = "";

                // 当允许编目功能的时候才能允许保存对象资源。否则会把书目记录摧毁为空记录
                if (this.Cataloging == true)
                {
                    // 提交对象保存请求
                    // return:
                    //		-1	error
                    //		>=0 实际上载的资源对象数
                    nRet = this.binaryResControl1.Save(
                        channel,
                        this.MainForm.ServerVersion,
                        out strError);
                    if (nRet == -1)
                    {
                        MessageBox.Show(this, "保存对象信息时出错: " + strError);
                        nErrorCount++;
                    }

                    if (nRet >= 1)
                    {
                        bObjectSaved = true;
                        if (strText != "")
                            strText += " ";
                        strText += "对象信息";

                        /*
                        string strSavedBiblioRecPath = this.BiblioRecPath;

                        // 刷新书目记录的时间戳
                        string strOutputBiblioRecPath = "";
                        string strXml = "";
                        nRet = LoadBiblioRecord(this.BiblioRecPath,
                            "",
                            false,
                            out strOutputBiblioRecPath,
                            out strXml,
                            out strError);
                        if (nRet == -1)
                        {
                            // 如果提取记录失败，并且原有书目记录路径被摧毁，需要恢复
                            if (String.IsNullOrEmpty(this.BiblioRecPath) == true)
                            {
                                this.BiblioRecPath = strSavedBiblioRecPath;
                            }

                            MessageBox.Show(this, strError + "\r\n\r\n注意：当前窗口内的书目记录时间戳可能没有正确刷新，这将导致后继的保存书目记录操作出现时间戳不匹配报错");
                            nErrorCount++;
                        }
                        */
                    }
                }

                if (string.IsNullOrEmpty(strHtml) == false)
                {
                    this.m_webExternalHost_biblio.SetHtmlString(strHtml,
    "entityform_biblio");
                }

                if (bDisplaySuccess == true)
                {
                    if (bEntitiesSaved == true
                        || bBiblioSaved == true
                        || bIssuesSaved == true
                        || bOrdersSaved == true
                        || bObjectSaved == true
                        || bCommentsSaved == true)
                        this.MainForm.StatusBarMessage = strText + " 保存 成功";
                }

                if (nErrorCount > 0)
                {
                    return -1;
                }

                // 保存成功后再校验 MARC 记录
                if (bVerifyData == true
                    && this.AutoVerifyData == true
                    && bVerified == false)
                {
                    // TODO: 注意中途关闭 EntityForm 会发生什么
                    API.PostMessage(this.Handle, WM_VERIFY_DATA, 0, 0);
                }

                return 0;
            }
            finally
            {
                if (nErrorCount == 0)
                    this.ShowMessage("记录保存成功", "green", true);
                else
                    this.ShowMessage("记录保存失败", "red", true);

                Progress.EndLoop();
                Progress.OnStop -= new StopEventHandler(this.DoStop);
                Progress.Initial("");

                this.ReturnChannel(channel);
            }
        }


		        // TODO: 有这样一种情况：虽然书目记录和下属的记录都不存在，但是窗口内容被改变了，已然不是以前的内容。如果这时保存记录，会有意外发生，例如本来就有的册信息被清空了。
        // 要想办法在这种情况下保持窗口内全部信息不变；或者，既然已经改变，索性把MARC窗内的记录全部清除，书目记录路径也清楚，避免误会
        // parameters:
        //      bWarningNotSave 是否警告尚未保存？如果==false，并且“自动保存”checkbox为true，会自动保存，不警告
        //      bSetFocus   装载完成后是否把焦点切换到MarcEditor上
        // return:
        //      -1  出错
        //      0   没有装载(例如发现窗口内的记录没有保存，出现警告对话框后，操作者选择了Cancel；或者“到头”“到尾”)
        //      1   成功装载
        //      2   通道被占用
        /// <summary>
        /// 装载记录
        /// </summary>
        /// <param name="strBiblioRecPath">书目记录路径</param>
        /// <param name="strPrevNextStyle">前后翻动风格</param>
        /// <param name="bCheckInUse">是否检查通道占用情况</param>
        /// <param name="bSetFocus">装载完成后是否把焦点切换到MarcEditor上</param>
        /// <param name="strTotalError">返回总的出错情况</param>
        /// <param name="bWarningNotSave">是否警告尚未保存？如果==false，并且“自动保存”checkbox为true，会自动保存，不警告</param>
        /// <returns>
        ///      -1  出错
        ///      0   没有装载(例如发现窗口内的记录没有保存，出现警告对话框后，操作者选择了Cancel；或者“到头”“到尾”)
        ///      1   成功装载
        ///      2   通道被占用
        /// </returns>
        public int LoadRecord(string strBiblioRecPath,
            string strPrevNextStyle,
            bool bCheckInUse,
            bool bSetFocus,
            out string strTotalError,
            bool bWarningNotSave = false)
        {
            strTotalError = "";

            if (Progress.IsInLoop == true && Progress.AllowNest == false)
            {
                strTotalError = "种册窗正在执行长操作。装载书目记录 "
                    + strBiblioRecPath
                    + (string.IsNullOrEmpty(strPrevNextStyle) == true ? "" : "|" + strPrevNextStyle)
                    + " 的操作被放弃。请稍后重试";
                return 2;
            }

            string strError = "";

            bool bMarcEditorContentChanged = false; // MARC编辑器内的内容可曾修改?
            bool bBiblioRecordExist = false;    // 书目记录是否存在?
            bool bSubrecordExist = false;   // 至少有一个从属的记录存在
            bool bSubrecordListCleared = false; // 子记录的list是否被清除了?

            string strOutputBiblioRecPath = "";

            if (this.EntitiesChanged == true
                || this.IssuesChanged == true
                || this.BiblioChanged == true
                || this.ObjectChanged == true
                || this.OrdersChanged == true
                || this.CommentsChanged == true)
            {
                // 2008/6/25 
                if (this.checkBox_autoSavePrev.Checked == true
                    && bWarningNotSave == false)
                {
                    int nRet = this.DoSaveAll();
                    if (nRet == -1)
                    {
                        // strTotalError = "当前记录尚未保存";  // 2014/7/8
                        return -1;
                    }
                }
                else
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。若此时装载新内容，现有未保存信息将丢失。\r\n\r\n确实要装入新内容? ",
                        "EntityForm",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.No)
                        return 0;
                }
            }

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 1, 0);    // 保存大量册记录时可能会耗时长一点

            string strMessage = "正在装载书目记录 " + strBiblioRecPath + " " + strPrevNextStyle + " ...";
            Progress.OnStop += new StopEventHandler(this.DoStop);
            Progress.Initial(strMessage);
            Progress.BeginLoop();

            this.ShowMessage(strMessage);

            EnableControls(false);
            try
            {
                // 2012/7/25 移动到这里
                // 因为 LoadBiblioRecord() 会导致填充AutoGen菜单
                this._genData.ClearViewer();

                if (this.m_commentViewer != null)
                    this.m_commentViewer.Clear();

                bool bLoadSubrecords = true;
                if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.91") < 0)
                    bLoadSubrecords = false;


                string strXml = "";
                string strSubRecords = "";
                int nRet = this.LoadBiblioRecord(
                    channel,
                    strBiblioRecPath,
                    strPrevNextStyle,
                    false,
                    bLoadSubrecords,
                    out strOutputBiblioRecPath,
                    out strXml,
                    out strSubRecords,
                    out strError);
                if (nRet == -1)
                {
                    string strErrorText = "装载书目记录 '" + strBiblioRecPath + "' (style='" + strPrevNextStyle + "')时发生错误: " + strError;
#if NO
                            Global.SetHtmlString(this.webBrowser_biblioRecord,
                                strErrorText);
#endif
                    this.m_webExternalHost_biblio.SetHtmlString(strErrorText, "entityform_error");

                    // MessageBox.Show(this, strErrorText);
                    if (String.IsNullOrEmpty(strTotalError) == false)
                        strTotalError += "\r\n";
                    strTotalError += strErrorText;
                }
                else if (nRet == 0)
                {
                    bBiblioRecordExist = false;
                    // 虽然种记录不存在，但是也继续装载册记录
                    // return 0;

                    string strText = "";

                    // 在不是前后翻看记录的情况下，要清空MARC窗，避免误会
                    if (String.IsNullOrEmpty(strPrevNextStyle) == true)
                    {
                        strText = "书目记录 '" + strBiblioRecPath + "' 没有找到...";

                        // 清空MARC窗，避免误会
                        // this.m_marcEditor.Marc = "012345678901234567890123";
                        this.SetMarc("012345678901234567890123");
                        bMarcEditorContentChanged = true;

                        // 如果书目记录不存在，则沿用strBiblioRecPath的路径
                        if (String.IsNullOrEmpty(strOutputBiblioRecPath) == true)
                        {
                            strOutputBiblioRecPath = strBiblioRecPath;
                        }
                    }
                    else
                    {
                        if (strPrevNextStyle == "prev")
                            strText = "到头";
                        else if (strPrevNextStyle == "next")
                            strText = "到尾";

                        strText += "\r\n\r\n(窗口内的原记录没有被刷新)";

                        strOutputBiblioRecPath = "";    // 这时候继续装载下属记录也无法进行了，因为不知道书目记录的路径。TODO: 将来可以采用猜测法，把书目记录路径+1或者-1,直到遇到下一条记录
                        // MessageBox.Show(this, strText);

                        if (String.IsNullOrEmpty(strTotalError) == false)
                            strTotalError += "\r\n";
                        strTotalError += strText;

                        return 0;   // 2008/11/2 
                    }

                    // MessageBox.Show(this, strText);
                    if (String.IsNullOrEmpty(strTotalError) == false)
                        strTotalError += "\r\n";
                    strTotalError += strText;
                }
                else
                {
                    bBiblioRecordExist = true;
                }

                bool bError = false;

                // 注：当bBiblioRecordExist==true时，LoadBiblioRecord()函数中已经设好了书目记录路径

                strBiblioRecPath = null;    // 防止后面继续使用。因为prev/next风格时，strBiblioRecPath的路径并不是所获得的记录的路径

                // 清空4个下属记录的控件
                this.entityControl1.ClearItems();
                this.textBox_itemBarcode.Text = ""; // 2009/1/5 

                this.issueControl1.ClearItems();
                this.orderControl1.ClearItems();   // 2008/11/2 
                this.commentControl1.ClearItems();
                this.binaryResControl1.Clear(); // 2008/11/2 
                if (this.m_verifyViewer != null)
                    this.m_verifyViewer.Clear();
                /*
                if (this.m_genDataViewer != null)
                    this.m_genDataViewer.Clear();
                 * */

                bSubrecordListCleared = true;

                XmlDocument collection_dom = new XmlDocument();
                if (string.IsNullOrEmpty(strSubRecords) == false)
                    collection_dom.LoadXml(strSubRecords);

                if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                {
                    string strBiblioDbName = "";

                    /*
                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                        strBiblioDbName = Global.GetDbName(strOutputBiblioRecPath);
                    else
                    {
                        Debug.Assert(String.IsNullOrEmpty(strBiblioRecPath) == false, "");
                        strBiblioDbName = Global.GetDbName(strBiblioRecPath);
                    }
                     * */
                    strBiblioDbName = Global.GetDbName(strOutputBiblioRecPath);

                    // 接着装入相关的所有册
                    string strItemDbName = this.MainForm.GetItemDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strItemDbName) == false) // 仅在当前书目库有对应的实体库时，才装入册记录
                    {
                        this.EnableItemsPage(true);

                        if (IsAccessDenied(collection_dom, "item"))
                            this.entityControl1.ErrorInfo = "权限不足，获取实体信息被拒绝";
                        else
                        {
                            nRet = this.entityControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,    // 2008/11/2 new changed
                                GetItems(collection_dom, "item"),
                                // this.DisplayOtherLibraryItem,
                                this.DisplayOtherLibraryItem == true ? "getotherlibraryitem" : "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载册记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.entityControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableItemsPage(false);
                    }

                    // 接着装入相关的所有期
                    string strIssueDbName = this.MainForm.GetIssueDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strIssueDbName) == false) // 仅在当前书目库有对应的期库时，才装入期记录
                    {
                        this.EnableIssuesPage(true);

                        if (IsAccessDenied(collection_dom, "issue"))
                            this.issueControl1.ErrorInfo = "权限不足，获取期信息被拒绝";
                        else
                        {

                            nRet = this.issueControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,  // 2008/11/2 changed
                                GetItems(collection_dom, "issue"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载期记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.issueControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableIssuesPage(false);
                    }

                    // 接着装入相关的所有订购信息
                    string strOrderDbName = this.MainForm.GetOrderDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strOrderDbName) == false) // 仅在当前书目库有对应的采购库时，才装入采购记录
                    {
                        if (String.IsNullOrEmpty(strIssueDbName) == false)
                            this.orderControl1.SeriesMode = true;
                        else
                            this.orderControl1.SeriesMode = false;

                        this.EnableOrdersPage(true);

                        if (IsAccessDenied(collection_dom, "order"))
                            this.orderControl1.ErrorInfo = "权限不足，获取订购信息被拒绝";
                        else
                        {

                            nRet = this.orderControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,  // 2008/11/2 changed
                                GetItems(collection_dom, "order"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载订购记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.orderControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableOrdersPage(false);
                    }

                    // 接着装入相关的所有评注信息
                    string strCommentDbName = this.MainForm.GetCommentDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strCommentDbName) == false) // 仅在当前书目库有对应的采购库时，才装入采购记录
                    {
                        this.EnableCommentsPage(true);

                        if (IsAccessDenied(collection_dom, "comment"))
                            this.commentControl1.ErrorInfo = "权限不足，获取评注信息被拒绝";
                        else
                        {

                            nRet = this.commentControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,
                                GetItems(collection_dom, "comment"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载评注记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.commentControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableCommentsPage(false);
                    }

                    // 接着装入对象资源
                    {
                        nRet = this.binaryResControl1.LoadObject(
                            channel,
                            strOutputBiblioRecPath,    // 2008/11/2 changed
                            strXml,
                            this.MainForm.ServerVersion,
                            out strError);
                        if (nRet == -1)
                        {
                            strError = "装载对象记录时出错: " + strError;

                            if (channel.ErrorCode == ErrorCode.AccessDenied)
                            {
                                // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                this.binaryResControl1.ErrorInfo = strError;
                            }
                            else
                            {
                                // MessageBox.Show(this, strError);
                                if (String.IsNullOrEmpty(strTotalError) == false)
                                    strTotalError += "\r\n";
                                strTotalError += strError;

                                bError = true;
                                // return -1;
                            }
                        }

                        if (nRet == 1)
                            bSubrecordExist = true;
                    }

                    // 装载书目和<dprms:file>以外的其它XML片断
                    if (string.IsNullOrEmpty(strXml) == false)
                    {
                        nRet = LoadXmlFragment(strXml,
                            out strError);
                        if (nRet == -1)
                        {
                            if (String.IsNullOrEmpty(strTotalError) == false)
                                strTotalError += "\r\n";
                            strTotalError += strError;

                            bError = true;
                        }
                    }
                } // end of if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)

                if (string.IsNullOrEmpty(this.m_strUsedActiveItemPage) == false)
                {
                    // 只要有实体库，即便当前书目记录没有下属的实体记录，也要显示册listview page
                    if (LoadActiveItemIssuePage(m_strUsedActiveItemPage) == true)
                        this.m_strUsedActiveItemPage = "";
                }

                if (bBiblioRecordExist == false && bSubrecordExist == true)
                    this.BiblioRecPath = strOutputBiblioRecPath;

                if (bBiblioRecordExist == false
                    && bSubrecordExist == false
                    && bSubrecordListCleared == true)
                {
                    if (bMarcEditorContentChanged == false)
                    {
                        this.m_marcEditor.Marc = "012345678901234567890123";
                        this.SetMarc("012345678901234567890123");
                        bMarcEditorContentChanged = true;
                    }

                    if (this.DeletedMode == false)
                        this.BiblioRecPath = "";    // 避免残余记录覆盖了不该覆盖的记录
                }

                // 2008/11/2 
                if (bMarcEditorContentChanged == true)
                    this.BiblioChanged = false; // 避免后面自动保存时错误覆盖了不该覆盖的记录

                // 2008/9/16 
                this.DeletedMode = false;

                if (bError == true)
                    return -1;

                // 2013/11/13
                if (bBiblioRecordExist == false
&& bSubrecordExist == false
&& bSubrecordListCleared == true)
                    return -1;

                // 2008/11/26 
                if (m_strFocusedPart == "marceditor"
                    && bSetFocus == true)
                {
                    SwitchFocus(MARC_EDITOR);
                }

                DoViewComment(false);
                return 1;
            }
            finally
            {
                EnableControls(true);

                Progress.EndLoop();
                Progress.OnStop -= new StopEventHandler(this.DoStop);
                Progress.Initial("");

                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                // this.m_nChannelInUse--;
                this.ClearMessage();
            }
        }


		        // 移动书目记录
        private void toolStripButton_marcEditor_moveTo_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.95") < 0)   // "2.39"
            {
                strError = "本功能需要配合 dp2library 2.95 或以上版本才能使用";
                goto ERROR1;
            }

            string strTargetRecPath = this.m_marcEditor.Record.Fields.GetFirstSubfield("998", "t");
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
            {
                DialogResult result = MessageBox.Show(this,
    "当前窗口内的记录原本是从 '" + strTargetRecPath + "' 复制过来的。是否要移动回原有位置？\r\n\r\nYes: 是; No: 否，继续进行普通移动操作; Cancel: 放弃本次操作",
    "EntityForm",
    MessageBoxButtons.YesNoCancel,
    MessageBoxIcon.Question,
    MessageBoxDefaultButton.Button1);
                if (result == System.Windows.Forms.DialogResult.Cancel)
                    return;
                if (result == System.Windows.Forms.DialogResult.Yes)
                {
                    // strTargetRecPath会发生作用
                }

                if (result == System.Windows.Forms.DialogResult.No)
                {
                    strTargetRecPath = "";
                }
            }

            // 源记录就是 ？
            if (Global.IsAppendRecPath(this.BiblioRecPath) == true)
            {
                strError = "源记录尚未建立，无法执行移动操作";
                goto ERROR1;
            }

            // string strMergeStyle = "";
            MergeStyle merge_style = MergeStyle.CombineSubrecord | MergeStyle.ReserveSourceBiblio;

            BiblioSaveToDlg dlg = new BiblioSaveToDlg();
            MainForm.SetControlFont(dlg, this.Font, false);

            dlg.Text = "移动书目记录到 ...";
            dlg.MainForm = this.MainForm;
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
                dlg.RecPath = strTargetRecPath;
            else
            {
                dlg.RecPath = this.MainForm.AppInfo.GetString(
                    "entity_form",
                    "move_to_used_path",
                    this.BiblioRecPath);
                dlg.RecID = "?";
            }

            dlg.MessageText = "将当前窗口中的书目记录 " + this.BiblioRecPath + " (连同下属的册、期、订购、实体记录和对象资源)移动到:";
            dlg.CopyChildRecords = true;
            dlg.EnableCopyChildRecords = false;

            dlg.BuildLink = false;

            {
                string strMarcSyntax = this.GetCurrentMarcSyntax();
                if (string.IsNullOrEmpty(strMarcSyntax) == true)
                    strMarcSyntax = this.MarcSyntax;    // 外来数据的 MARC 格式

                dlg.MarcSyntax = strMarcSyntax;
            }

            // dlg.CurrentBiblioRecPath = this.BiblioRecPath;
            this.MainForm.AppInfo.LinkFormState(dlg, "entityform_BiblioMoveToDlg_state");
            dlg.ShowDialog(this);
            // this.MainForm.AppInfo.UnlinkFormState(dlg);

            if (dlg.DialogResult != DialogResult.OK)
                return;

            if (this.BiblioRecPath == dlg.RecPath)
            {
                strError = "要移动到的位置 '" + dlg.RecPath + "' 和当前记录本来的位置 '" + this.BiblioRecPath + "' 相同，移动操作被拒绝。若确实要这样保存记录，请直接使用保存功能。";
                goto ERROR1;
            }

            this.MainForm.AppInfo.SetString(
    "entity_form",
    "move_to_used_path",
    dlg.RecPath);

            {
                // 如果当前记录没有保存，则先保存
                if (//this.EntitiesChanged == true
                    //|| this.IssuesChanged == true
                    //|| this.BiblioChanged == true
        this.ObjectChanged == true
                    //|| this.OrdersChanged == true
                    //|| this.CommentsChanged == true
                )
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。移动操作前必须先保存当前记录。\r\n\r\n请问要立即保存么？\r\n\r\n(OK: 保存; Cancel: 放弃本次移动操作)",
                        "EntityForm",
                        MessageBoxButtons.OKCancel,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.OK)
                    {
                        // 提交所有保存请求
                        // return:
                        //      -1  有错。此时不排除有些信息保存成功。
                        //      0   成功。
                        nRet = DoSaveAll();
                        if (nRet == -1 || nRet == -2)
                        {
                            strError = "因为保存操作出错，所以后续的移动操作被放弃";
                            goto ERROR1;
                        }
                    }
                    else
                    {
                        strError = "移动操作被放弃";
                        goto ERROR1;
                    }
                }
            }

            // 看看要另存的位置，记录是否已经存在?
            if (dlg.RecID != "?")
            {
                byte[] timestamp = null;

                // 检测特定位置书目记录是否已经存在
                // parameters:
                // return:
                //      -1  error
                //      0   not found
                //      1   found
                nRet = DetectBiblioRecord(dlg.RecPath,
                    out timestamp,
                    out strError);
                if (nRet == 1)
                {
                    //bool bOverwrite = false;
                    if (dlg.RecPath != strTargetRecPath)    // 移动回998$t情况就不询问是否覆盖了，直接选用归并方式
                    {
#if NO
                        // TODO: 用专用对话框实现
                        // 提醒覆盖？
                        DialogResult result = MessageBox.Show(this,
                            "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n要用当前窗口中的书目记录(连同数字对象和下属的子记录)覆盖此记录，还是归并到此记录? \r\n\r\nYes: 覆盖; No: 归并; Cancel: 放弃本次移动操作",
                            "EntityForm",
                            MessageBoxButtons.YesNoCancel,
                            MessageBoxIcon.Question,
                            MessageBoxDefaultButton.Button2);
                        if (result == DialogResult.Cancel)
                            return;
                        if (result == System.Windows.Forms.DialogResult.Yes)
                            bOverwrite = true;
                        else
                            bOverwrite = false;
#endif
                        GetMergeStyleDialog merge_dlg = new GetMergeStyleDialog();
                        MainForm.SetControlFont(merge_dlg, this.Font, false);
                        merge_dlg.SourceRecPath = this.BiblioRecPath;
                        merge_dlg.TargetRecPath = dlg.RecPath;
                        merge_dlg.MessageText = "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n请指定当前窗口中的书目记录(源)和此目标记录合并的方法";

                        merge_dlg.UiState = this.MainForm.AppInfo.GetString(
        "entity_form",
        "GetMergeStyleDialog_uiState",
        "");
                        this.MainForm.AppInfo.LinkFormState(merge_dlg, "entityform_GetMergeStyleDialog_state");
                        merge_dlg.ShowDialog(this);
                        this.MainForm.AppInfo.UnlinkFormState(merge_dlg);
                        this.MainForm.AppInfo.SetString(
"entity_form",
"GetMergeStyleDialog_uiState",
merge_dlg.UiState);

                        if (merge_dlg.DialogResult == System.Windows.Forms.DialogResult.Cancel)
                            return;

                        merge_style = merge_dlg.GetMergeStyle();
                    }

                    // this.BiblioTimestamp = timestamp;   // 为了顺利覆盖

                    // TODO: 预先检查操作者权限，确保删除书目记录和下级记录都能成功，否则就警告

#if NO
                    if (bOverwrite == true)
                    {
                        // 删除目标位置的书目记录
                        // 如果为归并模式，则保留其下属的实体等记录
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            bOverwrite == true ? "delete" : "onlydeletebiblio",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                    }
#endif
                    if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                    {
                        // 删除目标记录整个，或者删除目标位置的下级记录
                        // TODO: 测试的时候，注意不用下述调用而测试保留目标书目记录中对象的可能性
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            (merge_style & MergeStyle.ReserveSourceBiblio) != 0 ? "delete" : "onlydeletesubrecord",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                        {
                            if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 时出错: " + strError;
                            else
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 的全部子记录时出错: " + strError;
                            goto ERROR1;
                        }
                    }
                }
            }

            string strOutputBiblioRecPath = "";
            byte[] baOutputTimestamp = null;
            string strXml = "";

            string strOldBiblioRecPath = this.BiblioRecPath;
            string strOldMarc = this.GetMarc(); //  this.m_marcEditor.Marc;
            bool bOldChanged = this.GetMarcChanged();   // this.m_marcEditor.Changed;
            bool bSucceed = false;

            this.EnableControls(false);

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 2, 0);    // 查重和复制一般都需要较长时间

            try
            {
                // 保存原来的记录路径
                bool bOldReadOnly = this.m_marcEditor.ReadOnly;
                Field old_998 = null;

                string strDlgTargetDbName = Global.GetDbName(dlg.RecPath);
                string str998TargetDbName = Global.GetDbName(strTargetRecPath);

                // 如果移动目标和strTargetRecPath同数据库，则要去掉记录中可能存在的998$t
                if (strDlgTargetDbName == str998TargetDbName)
                {
                    // 保存当前记录的998字段
                    old_998 = this.m_marcEditor.Record.Fields.GetOneField("998", 0);

                    // 清除可能存在的998$t
                    if (old_998 != null)
                    {
                        SubfieldCollection subfields = old_998.Subfields;
                        Subfield old_t = subfields["t"];
                        if (old_t != null)
                        {
                            old_998.Subfields = subfields.Remove(old_t);
                            // 如果998内一个子字段也没有了，是否这个字段要删除?
                        }
                        else
                            old_998 = null; // 表示(既然没有删除$t，就)不用恢复
                    }
                }

                string strMergeStyle = "";
                if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                    strMergeStyle = "reserve_source";
                else
                    strMergeStyle = "reserve_target";

                if ((merge_style & MergeStyle.MissingSourceSubrecord) != 0)
                    strMergeStyle += ",missing_source_subrecord";
                else if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                {
                    // dp2library 尚未实现这个功能，不过本函数前面已经用 SetBiblioInfo() API 主动删除了目标位置下属的子记录，效果是一样的。(当然，这样实现起来原子性不是那么好)
                    // strMergeStyle += ",overwrite_target_subrecord";
                }
                // combine 情况时缺省的，不用声明

                SavedInfo info = new SavedInfo();

                nRet = CopyBiblio(
                    channel,
                    "move",
                    dlg.RecPath,
                    strMergeStyle,
                    out strXml,
                    out strOutputBiblioRecPath,
                    out baOutputTimestamp,
                    out strError);
#if NO
                if (nRet == -1)
                    MessageBox.Show(this, strError);
#endif
                if (nRet == 0)
                {
                    info.bBiblioSaved = true;
                    info.SavedNames.Add("书目信息");
                    this.BiblioChanged = false;
                    this.BiblioRecPath = strOutputBiblioRecPath;
                    this.BiblioTimestamp = baOutputTimestamp;
                    bSucceed = true;
                }
                if (nRet == -1)
                {
                    info.ErrorCount++;
                    goto ERROR1; // 书目记录若保存不成功，后继的实体记录保存就没法定位正确的书目记录路径
                }

                {
                    /// 
                    LoadSubRecordsInfo load_info = new LoadSubRecordsInfo();

                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                    {
                        // 装载下级记录，为保存下级记录的修改做准备
                        nRet = LoadSubRecords(
                            channel,
                            strOutputBiblioRecPath,
                            null,   // strXml, // 书目记录 XML
                            "", // strSubRecords,
                            load_info,
                            true,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                        // TODO: load_info.ErrorCount ?
                    }

                    nRet = SaveSubRecords(channel,
                        info,
                        strOutputBiblioRecPath,
                        out strError);
                    if (nRet == -1)
                        return;
                }
            }
            finally
            {
                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                this.EnableControls(true);

#if NO
                // 复原当前窗口的记录
                if (this.m_marcEditor.Marc != strOldMarc)
                    this.m_marcEditor.Marc = strOldMarc;
                if (this.m_marcEditor.Changed != bOldChanged)
                    this.m_marcEditor.Changed = bOldChanged;
#endif
                if (bSucceed == false)
                {
                    if (this.GetMarc() /*this.m_marcEditor.Marc*/ != strOldMarc)
                    {
                        // this.m_marcEditor.Marc = strOldMarc;
                        this.SetMarc(strOldMarc);
                    }
                    if (this.GetMarcChanged() /*this.m_marcEditor.Changed*/ != bOldChanged)
                    {
                        // this.m_marcEditor.Changed = bOldChanged;
                        this.SetMarcChanged(bOldChanged);
                    }
                    this.BiblioRecPath = strOldBiblioRecPath;
                }
            }

#if NO
            // 将目标记录装入当前窗口
            this.LoadRecordOld(strOutputBiblioRecPath, "", false);
#endif
            return;
        ERROR1:
            MessageBox.Show(this, strError);
        }


		~~~~~~~~~~~~~~~~~

		        void FillItems(List<BiblioStore> items)
        {
            this.ClearMessage();

            StringBuilder text = new StringBuilder();

            string strBinDir = Environment.CurrentDirectory;

            string strCssUrl = Path.Combine(this.MainForm.DataDir, "Order\\BatchOrder.css");
            string strSummaryJs = Path.Combine(this.MainForm.DataDir, "Order\\BatchOrder.js");
            string strLink = "<link href='" + strCssUrl + "' type='text/css' rel='stylesheet' />";
            string strScriptHead = "<script type=\"text/javascript\" src=\"%bindir%/jquery/js/jquery-1.4.4.min.js\"></script>"
                + "<script type=\"text/javascript\" src=\"%bindir%/jquery/js/jquery-ui-1.8.7.min.js\"></script>"
                + "<script type='text/javascript' charset='UTF-8' src='" + strSummaryJs + "'></script>";
            // string strStyle = "<link href=\"%bindir%/select2/select2.min.css\" rel=\"stylesheet\" />" +
            // "<script src=\"%bindir%/select2/select2.min.js\"></script>";
            text.Append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head>"
                + strLink
                + strScriptHead.Replace("%bindir%", strBinDir)
                // + strStyle.Replace("%bindir%", strBinDir)
                + "</head><body>");

            AppendHtml(text.ToString(), false);
            text.Clear();

            int nStart = 0;
            foreach (BiblioStore item in items)
            {
                // Application.DoEvents();

                text.Append("\r\n<" + TABLE + " class=''>");

                text.Append("\r\n\t<" + TR + " class='check' biblio-recpath='" + item.RecPath + "' " + strOnClick + ">");
                text.Append("\r\n\t\t<" + TD + " class='biblio-index'><div>" + (nStart + 1).ToString() + "</div></" + TD + ">");
                text.Append("\r\n\t\t<" + TD + " class='nowrap' colspan='10'>"
                    + "<div class='biblio-head'>" + HttpUtility.HtmlEncode(item.RecPath) + "</div>"
                    + "<div class='biblio-table-container'>" + BuildBiblioHtml(item.RecPath, item.Xml) + "</div>"
                    + "</" + TD + ">");

                text.Append("\r\n\t</" + TR + ">");

                if (item.Orders.Count > 0)
                {
                    text.Append(GetOrderTitleLine());
                    int i = 0;
                    foreach (OrderStore order in item.Orders)
                    {
                        text.Append(BuildOrderHtml(item.RecPath, order, i, null));

                        i++;
                    }
                }

                nStart++;
                text.Append("\r\n</" + TABLE + ">");

                AppendHtml(text.ToString(), false);
                text.Clear();
            }
            text.Append("</body></html>");

            AppendHtml(text.ToString(), false);
            text.Clear();
#if NO
            Global.SetHtmlString(this.webBrowser1,
    text.ToString(),
    Program.MainForm.DataDir,
    "bo_");
#endif
        }


		~~~~~~~~~~~~~~~

		        internal void DoPrintPage(
            IWin32Window owner,
            LabelParam label_param,
            string strStyle,
            PrintPageEventArgs e)
        {
            string strError = "";
            int nRet = 0;

            if (e.Cancel == true)
                return;

            bool bTestingGrid = false;
            if (StringUtil.IsInList("TestingGrid", strStyle) == true)
                bTestingGrid = true;


            int nYCount = 0;
            int nXCount = 0;

            double PageWidth = label_param.PageWidth;
            double PageHeight = label_param.PageHeight;
#if NO
            if (label_param.Landscape == true)
            {
                double nTemp = PageHeight;
                PageHeight = PageWidth;
                PageWidth = nTemp;
            }
#endif
#if NO
            if (e.PageSettings.Landscape == true)
            {
                double nTemp = PageHeight;
                PageHeight = PageWidth;
                PageWidth = nTemp;
            }
#endif

            int nPageWidth = e.PageBounds.Width;    // PageBounds 中已经是按照 Landscape 处理过的方向了
            if (PageWidth != 0)
                nPageWidth = (int)PageWidth;

            int nPageHeight = e.PageBounds.Height;
            if (PageHeight != 0)
                nPageHeight = (int)PageHeight;

            DecimalPadding PageMargins = RotatePadding(label_param.PageMargins,
                e.PageSettings.Landscape);  // label_param.Landscape
#if NO
            // 垂直方向的个数
            nYCount = (e.PageBounds.Height - label_param.PageMargins.Top - label_param.PageMargins.Bottom)
                / label_param.Height;
            // 水平方向的个数
            nXCount = (e.PageBounds.Width - label_param.PageMargins.Left - label_param.PageMargins.Right)
            / label_param.Width;
#endif
            // 垂直方向的个数
            nYCount = (int)
                (
                (double)(nPageHeight - PageMargins.Top - PageMargins.Bottom)
                / (double)label_param.LabelHeight
                );
            // 水平方向的个数
            nXCount = (int)
                (
                (double)(nPageWidth - PageMargins.Left - PageMargins.Right)
                / (double)label_param.LabelWidth
                );

            int from = 0;
            int to = 0;
            bool bOutput = true;
            // 如果 e.PageSettings.PrinterSettings.FromPage == 0，会被当作打印第一页
            if (e.PageSettings.PrinterSettings.PrintRange == PrintRange.SomePages
                && e.PageSettings.PrinterSettings.FromPage >= 1)
            {
                from = e.PageSettings.PrinterSettings.FromPage;
                to = e.PageSettings.PrinterSettings.ToPage;

                // 交换，保证from为小
                if (from > to)
                {
                    int temp = to;
                    to = from;
                    from = temp;
                }

                if (this.m_nPageNo == 0)
                {
                    this.m_nPageNo = from;

                    Debug.Assert(this.m_nPageNo >= 1, "");
                    long nLabelCount = (nXCount * nYCount) * (this.m_nPageNo - 1);

                    // 从文件中跳过这么多label的内容行
                    for (int i = 0; i < nLabelCount; i++)
                    {
                        List<string> lines = null;
                        nRet = this.GetLabelLines(out lines,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;

                        if (nRet == 1)
                        {
                            e.Cancel = true;
                            return;
                        }
                    }
                }

                /*
                if (this.m_nPageNo >= from
                    && this.m_nPageNo <= to)
                {
                    bOutput = true;
                }
                else
                {
                    bOutput = false;
                }
                 * */
            }
            else
            {
                if (this.m_nPageNo == 0)
                    this.m_nPageNo = 1; // 一般性的初始化
            }


            // 加快运行速度
            float nXDelta = e.PageSettings.PrintableArea.Left;
            float nYDelta = e.PageSettings.PrintableArea.Top;

            /*
            if (this.PrintController.IsPreview == true)
            {
                nXDelta = 0;
                nYDelta = 0;
            }
             * */

            if (this.OriginAtMargins == true
                || this.PreviewMode == true)   // false
            {
                // true 如果图形起始于页面边距。否则起始于可打印区域
                nXDelta = 0;
                nYDelta = 0;
            }

            if (this.OriginPoint != null)
            {
                nXDelta -= this.OriginPoint.X;
                nYDelta -= this.OriginPoint.Y;
            }

#if NO
            float nPrintableWidth = e.PageSettings.PrintableArea.Width;
            float nPrintableHeight = e.PageSettings.PrintableArea.Height;
#endif


            if (this.IsDesignMode)
            {
                // 绘制整个纸张背景 白色
                using (Brush brushBack = new SolidBrush(Color.White))
                {
                    RectangleF rectPaper = new RectangleF(0 + 1 - nXDelta,
                        0 + 1 - nYDelta,
                        e.PageBounds.Width - 2,
                        e.PageBounds.Height - 2);
                    e.Graphics.FillRectangle(brushBack, rectPaper);
                }
            }

            // 绘制可打印区域
            // 鲜红色
            if (bTestingGrid == true && bOutput == true)
            {
                float nXOffs = 0;
                float nYOffs = 0;

                // 如果为正式打印，左上角(0,0)已经就是可以打印区域的左上角
                // 如果为preview模式，则左上角要向右向下移动，才能模拟出显示效果

#if NO
                if (this.OriginAtMargins == true
                    || this.PreviewMode == true)
                {
                    nXOffs = e.PageSettings.PrintableArea.Left;
                    nYOffs = e.PageSettings.PrintableArea.Top;
                }
#endif


                if (this.OriginPoint != null)
                {
                    nXOffs += this.OriginPoint.X;
                    nYOffs += this.OriginPoint.Y;
                }

                RectangleF rect = RotateRectangle(e.PageSettings.PrintableArea,
                    e.PageSettings.Landscape);  // label_param.Landscape

                if (this.OriginAtMargins == true
    || this.PreviewMode == true)
                {
                }
                else
                {
                    rect.X = 0;
                    rect.Y = 0;
                }

                rect.Offset(nXOffs, nYOffs);

                using (Pen pen = new Pen(Color.Red, (float)1))
                {
                    DrawFourAngel(
    e.Graphics,
    pen,
    rect,
    50);    // 半英寸
                }
            }

            // 加入变换
            e.Graphics.TranslateTransform(-nXDelta, -nYDelta);
            nXDelta = 0;
            nYDelta = 0;

            if (label_param.RotateDegree != 0)
            {
                float x_offs, y_offs;
                CenterMove(label_param.RotateDegree,
            (float)label_param.PageWidth,  // e.PageBounds.Width,
            (float)label_param.PageHeight, // e.PageBounds.Height,
            out x_offs,
            out y_offs);
                e.Graphics.TranslateTransform(x_offs, y_offs);
                e.Graphics.RotateTransform((float)label_param.RotateDegree);
            }

            if (this.IsDesignMode)
            {
                // 绘制配置文件的页面区域
                if (PageHeight > 0 && PageWidth > 0)
                {
                    using (Brush brushBack = new SolidBrush(Color.FromArgb(128, Color.LightYellow)))
                    {
                        RectangleF rectPaper = new RectangleF(0 - nXDelta,
                            0 - nYDelta,
                            (float)PageWidth,
                            (float)PageHeight);
                        e.Graphics.FillRectangle(brushBack, rectPaper);
                    }
                }
            }

            // 绘制内容区域边界(也就是排除了页面边空的中间部分)
            // 淡绿色
            if (bTestingGrid == true && bOutput == true)
            {
                using (Pen pen = new Pen(Color.FromArgb(0, 100, 0), (float)2)) // 3
                {

#if NO
                e.Graphics.DrawRectangle(pen,
                    PageMargins.Left - nXDelta,
                    PageMargins.Top - nYDelta,
                    e.PageBounds.Width - PageMargins.Left - PageMargins.Right,
                    e.PageBounds.Height - PageMargins.Top - PageMargins.Bottom);
#endif
                    e.Graphics.DrawRectangle(pen,
        (float)PageMargins.Left - nXDelta,
        (float)PageMargins.Top - nYDelta,
        (float)nPageWidth - (float)PageMargins.Left - (float)PageMargins.Right,
        (float)nPageHeight - (float)PageMargins.Top - (float)PageMargins.Bottom);

                }
            }

            bool bEOF = false;

            float y = (float)PageMargins.Top;
            // 每一行的循环
            for (int i = 0; i < nYCount; i++)
            {
                bool bDisplay = true;
                if (this.IsDesignMode == true)
                {
                    RectangleF rectLine = new RectangleF(
    (float)0 - nXDelta,
    (float)y - nYDelta,
    (float)label_param.LabelWidth * nXCount,
    (float)label_param.LabelHeight);
                    if (rectLine.Top > e.Graphics.ClipBounds.Bottom)
                    {
                        // Debug.WriteLine("break line loop at " + i.ToString());
                        break;  // 当前行在剪裁区域的下方，可以中断循环了
                    }
                    if (rectLine.IntersectsWith(e.Graphics.ClipBounds) == false)
                    {
                        // Debug.WriteLine("skip line " + i.ToString());
                        bDisplay = false;
                    }
                }
                float x = (float)PageMargins.Left;
                // 每一列的循环
                for (int j = 0; j < nXCount; j++)
                {
                    List<string> lines = null;
                    nRet = this.GetLabelLines(out lines,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    if (nRet == 1)
                        bEOF = true;

                    if (bOutput == true && bDisplay == true)
                    {
                        // 标签
                        RectangleF rectLabel = new RectangleF(
    (float)x - nXDelta,
    (float)y - nYDelta,
    (float)label_param.LabelWidth,
    (float)label_param.LabelHeight);

                        if (rectLabel.Left > e.Graphics.ClipBounds.Right)
                        {
                            // Debug.WriteLine("break label loop at i=" + i.ToString() + " j=" + j.ToString());
                            // 当前标签在剪裁区域的右方，可以不要显示后面的标签了
                            bDisplay = false;
                        }

                        if (this.IsDesignMode == false
                            || rectLabel.IntersectsWith(e.Graphics.ClipBounds) == true)
                        {
                            // Debug.WriteLine("i="+i.ToString()+" j="+j.ToString()+" rectLabel = "+rectLabel.ToString()+", clipbounds " + e.Graphics.ClipBounds.ToString());
                            // 标签内容区域
                            RectangleF rectContent = new RectangleF(
                                    (float)x + (float)label_param.LabelPaddings.Left - nXDelta,
                                    (float)y + (float)label_param.LabelPaddings.Top - nYDelta,
                                    (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right - 1,
                                    (float)label_param.LabelHeight - (float)label_param.LabelPaddings.Top - (float)label_param.LabelPaddings.Bottom - 1);


                            // 绘制标签边界
                            // 灰色
                            if (bTestingGrid == true)
                            {
                                // 标签白色背景
                                if (this.IsDesignMode == true)
                                {
                                    using (Brush brushBack = new SolidBrush(Color.FromArgb(200, Color.White)))
                                    {
                                        e.Graphics.FillRectangle(brushBack, rectLabel);
                                    }
                                }

                                // 标签边界
                                using (Pen pen = new Pen(Color.FromArgb(200, 200, 200), this.IsDesignMode ? (float)0.5 : (float)1))
                                {
                                    e.Graphics.DrawRectangle(pen,
                                        rectLabel.X,
                                        rectLabel.Y,
                                        rectLabel.Width,
                                        rectLabel.Height);
#if NO
                            e.Graphics.DrawRectangle(pen,
                                x - nXDelta,
                                y - nYDelta,
                                (float)label_param.LabelWidth,
                                (float)label_param.LabelHeight);
#endif

                                }


                                // 绘制标签内部文字区域边界
                                // 淡红色

                                using (Pen pen = new Pen(Color.FromArgb(255, 200, 200), this.IsDesignMode ? (float)0.5 : (float)1))
                                {
                                    e.Graphics.DrawRectangle(pen,
                                        rectContent.X,
                                        rectContent.Y,
                                        rectContent.Width,
                                        rectContent.Height);
#if NO
                            e.Graphics.DrawRectangle(pen,
                                (float)x + (float)label_param.LabelPaddings.Left - nXDelta,
                                (float)y + (float)label_param.LabelPaddings.Top - nYDelta,
                                (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right - 1,
                                (float)label_param.LabelHeight - (float)label_param.LabelPaddings.Top - (float)label_param.LabelPaddings.Bottom - 1);
#endif

                                }
                            }

#if NO
                        RectangleF clip = new RectangleF((float)x + (float)label_param.LabelPaddings.Left - nXDelta,
    (float)y + (float)label_param.LabelPaddings.Top - nYDelta,
    (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right,
    (float)label_param.LabelHeight - (float)label_param.LabelPaddings.Top - (float)label_param.LabelPaddings.Bottom);
#endif

                            using (Region old_clip = e.Graphics.Clip)
                            {
                                e.Graphics.IntersectClip(rectContent);

                                float y0 = 0;
                                for (int k = 0; k < lines.Count; k++)
                                {
                                    string strText = lines[k];

                                    LineFormat format = null;
                                    if (k < label_param.LineFormats.Count)
                                        format = label_param.LineFormats[k];

                                    Font this_font = null;
                                    bool bIsBarcodeFont = false;
                                    if (format != null && format.Font != null)
                                    {
                                        this_font = format.Font;
                                        bIsBarcodeFont = format.IsBarcodeFont;
                                    }
                                    else
                                    {
                                        this_font = label_param.Font;
                                        bIsBarcodeFont = label_param.IsBarcodeFont;
                                    }

                                    if (bIsBarcodeFont == true && string.IsNullOrEmpty(strText) == false)
                                        strText = "*" + strText + "*";

                                    float nLineHeight = this_font.GetHeight(e.Graphics);

                                    RectangleF rect = new RectangleF((float)x + (float)label_param.LabelPaddings.Left - nXDelta,
                                        (float)y + (float)label_param.LabelPaddings.Top + y0 - nYDelta,
                                        (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right,
                                        nLineHeight);

                                    bool bAbsLocation = false;
                                    // 行格式的 start 和 offset
                                    if (format != null)
                                    {
                                        if (double.IsNaN(format.StartX) == false)
                                            rect.X = (float)format.StartX;
                                        if (double.IsNaN(format.StartY) == false)
                                        {
                                            rect.Y = (float)format.StartY;
                                            bAbsLocation = true;    // Y 绝对定位后，行高度不参与累计
                                        }
                                        rect.Offset((float)format.OffsetX, (float)format.OffsetY);

                                        y0 += (float)format.OffsetY;    // Y 偏移后，累计值也跟着调整

                                    }

                                    StringFormat s_format = new StringFormat();
                                    if (format != null)
                                    {
                                        if (format.Align == "right")
                                            s_format.Alignment = StringAlignment.Far;
                                        else if (format.Align == "center")
                                            s_format.Alignment = StringAlignment.Center;
                                        else
                                            s_format.Alignment = StringAlignment.Near;

                                        s_format.Trimming = StringTrimming.EllipsisCharacter;
                                        // s_format.LineAlignment = StringAlignment.Center;
                                    }

                                    if (format != null && string.IsNullOrEmpty(format.BackColor) == false)
                                    {
                                        using (Brush brush = new SolidBrush(GetColor(format.BackColor)))
                                        {
                                            e.Graphics.FillRectangle(brush, rect);
                                        }
                                    }

                                    {
                                        Brush brushText = null;
                                        try
                                        {
                                            if (format != null && string.IsNullOrEmpty(format.ForeColor) == false)
                                            {
                                                brushText = new SolidBrush(GetColor(format.ForeColor));
                                            }
                                            else
                                                brushText = System.Drawing.Brushes.Black;

                                            e.Graphics.DrawString(strText,
                                                this_font,
                                                brushText,
                                                rect,
                                                s_format);
                                        }
                                        finally
                                        {
                                            if (brushText != System.Drawing.Brushes.Black)
                                                brushText.Dispose();
                                        }
                                    }


                                    // 文字行区域边界
                                    // 黑色点
                                    if (bTestingGrid == true && label_param.LineSep > 0)
                                    {
                                        using (Pen pen = new Pen(Color.Black, (float)1))
                                        {
                                            // pen.DashStyle = System.Drawing.Drawing2D.DashStyle.Custom;

#if NO
                                            e.Graphics.DrawRectangle(pen,
                                                rect.Left,
                                                rect.Top,
                                                rect.Width,
                                                rect.Height);
#endif
                                            pen.DashPattern = new float[] { 1F, 3F, 1F, 3F };
                                            e.Graphics.DrawLine(pen,
                                                new PointF(rect.Left, rect.Top),
                                                new PointF(rect.Right, rect.Top)
                                                );
                                            e.Graphics.DrawLine(pen,
                                                new PointF(rect.Left + 2, rect.Bottom),
                                                new PointF(rect.Right, rect.Bottom)
                                                );
                                        }
                                    }

                                    if (bAbsLocation == false)
                                        y0 += nLineHeight + (float)label_param.LineSep;
                                }

                                e.Graphics.Clip = old_clip;
                            } // end of using clip

                        } // end if IntersectsWith



                    } // end if bOutput == true


                    x += (float)label_param.LabelWidth;
                }

                //CONTINUE_LINE:
                y += (float)label_param.LabelHeight;
            }

            // If more lines exist, print another page.
            if (bEOF == false)
            {
                if (e.PageSettings.PrinterSettings.PrintRange == PrintRange.SomePages)
                {
                    if (this.m_nPageNo >= to)
                    {
                        e.HasMorePages = false;
                        return;
                    }
                }
            }
            else
            {
                e.HasMorePages = false;
                return;
            }

            this.m_nPageNo++;
            e.HasMorePages = true;
            return;
        ERROR1:
            MessageBox.Show(owner, strError);
        }


		~~~~~~~~~~~~~
		        void InstallBarcodeFont()
        {
            bool bInstalled = true;
            try
            {
                FontFamily family = new FontFamily("C39HrP24DhTt");
            }
            catch
            {
                bInstalled = false;
            }

            if (bInstalled == true)
            {
                // 已经安装
                return;
            }

            {
                string strFontFilePath = Path.Combine(this.DataDir, "b3901.ttf");
                int nRet = API.AddFontResourceA(strFontFilePath);
                if (nRet == 0)
                {
                    // 失败
                    MessageBox.Show(this, "安装字体文件 " + strFontFilePath + " 失败");
                    return;
                }
                // 为了解决 GDI+ 的一个 BUG
                // PrivateFontCollection m_pfc = new PrivateFontCollection();
                GlobalVars.PrivateFonts.AddFontFile(strFontFilePath);
            }

            {
                string strFontFilePath = Path.Combine(this.DataDir, "ocr-b.ttf");
                int nRet = API.AddFontResourceA(strFontFilePath);
                if (nRet == 0)
                {
                    // 失败
                    MessageBox.Show(this, "安装字体文件 " + strFontFilePath + " 失败");
                    return;
                }
                // 'OCR-B 10 BT' 字体
                GlobalVars.PrivateFonts.AddFontFile(strFontFilePath);
            }
#if NO
            /*
            try
            {
                FontFamily family = new FontFamily("C39HrP24DhTt");
            }
            catch (Exception ex)
            {
                bInstalled = false;
            }
             * */
            InstalledFontCollection enumFonts = new InstalledFontCollection();
            FontFamily[] fonts = enumFonts.Families;

            string strResult = "";
            foreach (FontFamily m in fonts)
            {
                strResult += m.Name + "\r\n";
            }

            int i = 0;
            i++;
#endif
        }


		~~~~~~~~~~~

		        void RemoveBarcodeFont()
        {
            GlobalVars.PrivateFonts.Dispose();

            {
                string strFontFilePath = Path.Combine(this.DataDir, "b3901.ttf");
                API.RemoveFontResourceA(strFontFilePath);
            }

            {
                string strFontFilePath = Path.Combine(this.DataDir, "ocr-b.ttf");
                API.RemoveFontResourceA(strFontFilePath);
            }
        }


		~~~~~~~~~
		        // 校验订购记录
        int VerifyOrderRecord(out string strError)
        {
            strError = "";
            int nRet = 0;

            bool bControl = Control.ModifierKeys == Keys.Control;

            Debug.Assert(this.DbType == "order", "");

            if (this.listView_records.SelectedItems.Count == 0)
            {
                strError = "尚未选定要进行批处理的事项";
                return -1;
            }

            if (stop != null && stop.State == 0)    // 0 表示正在处理
            {
                strError = "目前有长操作正在进行，无法进行校验订购记录的操作";
                return -1;
            }

            // 切换到“操作历史”属性页
            this.MainForm.ActivateFixPage("history");

            int nCount = 0;
            int nModifyCount = 0;

            this.MainForm.OperHistory.AppendHtml("<div class='debug begin'>" + HttpUtility.HtmlEncode(DateTime.Now.ToLongTimeString())
                + " 开始进行订购记录校验</div>");

            stop.Style = StopStyle.EnableHalfStop;
            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在进行校验订购记录的操作 ...");
            stop.BeginLoop();

            this.EnableControls(false);
            try
            {
                stop.SetProgressRange(0, this.listView_records.SelectedItems.Count);

                List<ListViewItem> items = new List<ListViewItem>();
                foreach (ListViewItem item in this.listView_records.SelectedItems)
                {
                    if (string.IsNullOrEmpty(item.Text) == true)
                        continue;

                    items.Add(item);
                }

                bool bOldSource = true; // 是否要从 OldXml 开始做起

                if (bControl)
                {
                    int nChangeCount = this.GetItemsChangeCount(items);
                    if (nChangeCount > 0)
                    {
                        bool bHideMessageBox = true;
                        DialogResult result = MessageDialog.Show(this,
                            "当前选定的 " + items.Count.ToString() + " 个事项中有 " + nChangeCount + " 项修改尚未保存。\r\n\r\n请问如何进行修改? \r\n\r\n(重新修改) 重新进行修改，忽略以前内存中的修改; \r\n(继续修改) 以上次的修改为基础继续修改; \r\n(放弃) 放弃整个操作",
        MessageBoxButtons.YesNoCancel,
        MessageBoxDefaultButton.Button1,
        null,
        ref bHideMessageBox,
        new string[] { "重新修改", "继续修改", "放弃" });
                        if (result == DialogResult.Cancel)
                        {
                            strError = "放弃";
                            return 0;
                        }
                        if (result == DialogResult.No)
                        {
                            bOldSource = false;
                        }
                    }
                }

                ListViewPatronLoader loader = new ListViewPatronLoader(this.Channel,
    stop,
    items,
    this.m_biblioTable);
                loader.DbTypeCaption = this.DbTypeCaption;

                int i = 0;
                foreach (LoaderItem item in loader)
                {
                    Application.DoEvents();	// 出让界面控制权

                    if (stop != null
                        && stop.State != 0)
                    {
                        strError = "用户中断";
                        return -1;
                    }

                    bool bChanged = false;

                    BiblioInfo info = item.BiblioInfo;

                    XmlDocument itemdom = new XmlDocument();
                    try
                    {
                        // itemdom.LoadXml(info.OldXml);
                        if (bOldSource == true)
                        {
                            itemdom.LoadXml(info.OldXml);
                            // 放弃上一次的修改
                            if (string.IsNullOrEmpty(info.NewXml) == false)
                            {
                                info.NewXml = "";
                                this.m_nChangedCount--;
                            }
                        }
                        else
                        {
                            if (string.IsNullOrEmpty(info.NewXml) == false)
                                itemdom.LoadXml(info.NewXml);
                            else
                                itemdom.LoadXml(info.OldXml);
                        }
                    }
                    catch (Exception ex)
                    {
                        strError = "记录 '" + info.RecPath + "' 的 XML 装入 DOM 时出错: " + ex.Message;
                        return -1;
                    }

                    List<string> errors = new List<string>();

                    // 检查根元素下的元素名是否有重复的
                    nRet = VerifyDupElementName(itemdom,
            out strError);
                    if (nRet == -1)
                        errors.Add(strError);

                    // 校验 XML 记录中是否有非法字符
                    string strReplaced = DomUtil.ReplaceControlCharsButCrLf(info.OldXml, '*');
                    if (strReplaced != info.OldXml)
                    {
                        errors.Add("XML 记录中有非法字符");
                    }

                    nRet = VerifyRefID(itemdom,
                        bControl,
                        out strError);
                    if (nRet == -1)
                    {
                        errors.Add(strError);
                        if (bControl)
                            bChanged = true;
                    }

                    nRet = VerifyOrder(itemdom,
                        bControl,
                        ref bChanged,
                        out strError);
                    if (nRet == -1)
                        errors.Add(strError);

                    if (errors.Count > 0)
                    {
                        this.MainForm.OperHistory.AppendHtml("<div class='debug recpath'>" + HttpUtility.HtmlEncode(info.RecPath) + "</div>");
                        foreach (string error in errors)
                        {
                            this.MainForm.OperHistory.AppendHtml("<div class='debug error'>" + HttpUtility.HtmlEncode(error) + "</div>");
                        }

                        {
                            item.ListViewItem.BackColor = Color.FromArgb(155, 0, 0);
                            item.ListViewItem.ForeColor = Color.FromArgb(255, 255, 255);
                        }
                    }

                    if (bChanged == true)
                    {
                        string strXml = itemdom.OuterXml;
                        Debug.Assert(info != null, "");
                        if (info != null)
                        {
                            if (string.IsNullOrEmpty(info.NewXml) == true)
                                this.m_nChangedCount++;
                            info.NewXml = strXml;
                        }

                        item.ListViewItem.BackColor = SystemColors.Info;
                        item.ListViewItem.ForeColor = SystemColors.InfoText;
                        nModifyCount++;
                    }

                    nCount++;
                    stop.SetProgressValue(++i);
                }

                return nCount;
            }
            finally
            {
                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();
                stop.Style = StopStyle.None;

                this.EnableControls(true);

                this.MainForm.OperHistory.AppendHtml("<div class='debug end'>" + HttpUtility.HtmlEncode(DateTime.Now.ToLongTimeString())
                    + " 结束执行订购记录校验</div>");
                if (nModifyCount > 0)
                    this.MainForm.OperHistory.AppendHtml("<div class='debug end'>" + HttpUtility.HtmlEncode(DateTime.Now.ToLongTimeString())
                        + " 发生修改 " + nModifyCount + " 条</div>");
            }
        }
