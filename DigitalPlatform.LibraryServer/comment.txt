
Login() API 的 strParameters 参数里面可以包含 clientip 子参数

但因为在 ChannelPool 使用方式下，寻找空闲通道是按照 userName 来匹配的。
可能得到一根 userName 匹配，但用过的 clientIP 和当前 clientIP 并不相同。
这时候如果再分配一根新通道，比较浪费。最好是复用这根通道。
那么就需要有一个 API 可以动态设置通道的 clientIP。dp2library 响应这个
“修改 clientIP”的请求时，要像第一次创建通道时一样，检查这个 clientIP 所对应
的总通道数是否超过了配额，如果超过了则出错返回；如果没有超过则成功返回(返回前要增量所请求的 clientIP 的配额，减量一次被改掉的原 clientIP 的配额)。

有时候也可以考虑为 Login() API 的 clientip 子参数使用一个虚拟的 IP 地址字符串，例如
#opac，表示这些全都都是 dp2OPAC 发起的请求，算作同一个 IP 地址。

还有一个办法就是前端，使用 LibraryChannel 的时候，前端自己约束自己，保证所用
的通道数不超过一个配额。

order权限
囊括了
getitemifo

getorderinfo

getissueinfo

setorderinfo

searchitem

searchorder

searchitemdup

searchorderdup

getbibliosummary,

searchbiblio

getbiblioinfo,listbibliodbfroms,getsystemparameter,

~~~
2024/1/29
Borrow() API 中从册记录中读取信息验证当前读者证条码号(GetBorrowerBarcode())要考虑双链变化为 refID 以后的兼容性

册记录中 borrower 元素的内容，改为写入 @refID:xxxx。以前的 证条码号形态 依然有效，注意使用的时候加以判断

Borrow() API 返回的 BorrowInfo 结构中，strItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
*** 注意验证内务等前端的适应性


读者记录中 borrows/borrow 元素中，增加了一个 refID 属性，值为册记录的参考 ID。原有的 barcode 属性依然有效，是册条码号


Borrow() API 的操作日志记录，增加了一个 readerRefID 元素，里面是读者参考 ID。原有的 readerBarcode 元素没有变化，内容依然是读者证条码号
... 增加了一个 itemRefID 元素，里面是册参考 ID。原有的 itemBarcode 元素不变，内容依然是册条码号(少量可能是 @refID:xxx 形态)


~~~
Return() API 返回的 ReturnInfo 结构中，ItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
... Borrower 字段的内容增加了一种可能性 @refID:xxx 形态
*** 注意验证内务等前端的适应性

Return() API 的操作日志记录，增加一个 readerRefID 元素。
... 增加了一个 itemRefID 元素。

~~~
Reservation() API 中，预约时对册记录的 reservations/request/@reader 属性中写入的可能是证条码号或 @refID:xxx 形态

预约队列记录中增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

Reservation() API 的操作日志记录中，增加了一个 itemRefIdList 元素。原有 itemBarcodeList 元素依然有效
... 增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

~~~
读者记录中 reservations/request 元素的 arrivedItemBarcode 属性，可能是册条码号，也可能是 @refID:xxx 形态

~~~
根据操作日志记录重建 mongodb 借阅历史库的冒烟测试

~~~
重新检查日志前滚中对借还相关的日志动作的处理，要适应新旧两种日志格式

~~~
日志记录的 version 变化

~~~
检查预约到书记录的时候，如果发现相关的读者记录或册记录已经不存在，要写入错误日志以后，
继续向后通知下一个读者。
类似地，删除读者记录的时候，要检查有没有相关的到书状态的预约到书记录，如果有，
要做通知下一个读者处理。
删除册记录的时候，也要进行类似检查，看看怎么处理合适。

~~~
日志恢复过程中，要关注当前是否启用了 mongodb 出纳历史库。如果启用了，要和平时一样，
把每一笔恢复的日志动作，兑现到加入 mongodb 出纳历史库。这里可以沿用平时的机制和函数。


~~~
***
测试验证读者身份登录
读者身份使用 SearchCharging() API 只允许用读者参考 ID 查询。建议增加可以用册参考 ID 查询，但要(过滤)限定只返回这个读者(针对这一册图书)的借阅历史
临时的SessionInfo对象，模拟内部调用，需要统一函数。解决写入操作日志时 operator 为空的问题
读者身份登录进行借书还书操作。包括个人书斋情形
制造一条读者记录，证条码号字段为空，用参考 ID 登录应该成功
用这条没有证条码号的读者记录进行借还等等测试，应该成功


~~~
读者记录中 overdue 元素增加 refID 属性，内容为超期册的参考 ID
违约金记录增加 itemRefID 元素，内容为超期册的参考 ID
注意违约金记录中的 itemBarcode 元素内容可能是 @refID:xxx 形态，较早版本就已经是这样了

Amerce() API 的 rollback 功能需要冒烟测试一下

~~~
当前滚经过的日志记录明确表明一个书目库或者读者库被删除(并且也确实兑现了删除)，那么此后再遇到
需要临时创建这个数据库，就可以考虑态度为不予理会了。但注意，后面可能又有新的日志记录表明创建了这个数据库，则不予理会的作用域会停止起作用。

~~~
理论上来说，如果从任何一个点开始前滚(注: 此前没有从大备份恢复过，而是直接从全新安装开始)
先要自动向较早时间回溯，找到所有的创建和变更、删除数据库的动作，并据此构造出全部数据库
以后，再启动前滚，才是正确的做法。
不过，可能会遇到较早版本的日志记录中缺乏有关数据库的动作记录的问题。

~~~
setUser 操作日志动作是否要增加前滚实现?
修改读者密码的动作是否要前滚实现?
OPAC 显示格式的 library.xml 中配置部分需要前滚兑现么？
dp2library 安装时创建的三个辅助数据库(违约金、预约到书、消息)，日志前滚时候是否兑现重建的动作?

~~~
版本升级时，如果没有配置 mongodb 相关参数，则升级批处理依然要进行，
要把为读者记录和册记录添加 refID 元素的动作写入操作日志文件