
Login() API 的 strParameters 参数里面可以包含 clientip 子参数

但因为在 ChannelPool 使用方式下，寻找空闲通道是按照 userName 来匹配的。
可能得到一根 userName 匹配，但用过的 clientIP 和当前 clientIP 并不相同。
这时候如果再分配一根新通道，比较浪费。最好是复用这根通道。
那么就需要有一个 API 可以动态设置通道的 clientIP。dp2library 响应这个
“修改 clientIP”的请求时，要像第一次创建通道时一样，检查这个 clientIP 所对应
的总通道数是否超过了配额，如果超过了则出错返回；如果没有超过则成功返回(返回前要增量所请求的 clientIP 的配额，减量一次被改掉的原 clientIP 的配额)。

有时候也可以考虑为 Login() API 的 clientip 子参数使用一个虚拟的 IP 地址字符串，例如
#opac，表示这些全都都是 dp2OPAC 发起的请求，算作同一个 IP 地址。

还有一个办法就是前端，使用 LibraryChannel 的时候，前端自己约束自己，保证所用
的通道数不超过一个配额。

order权限
囊括了
getitemifo

getorderinfo

getissueinfo

setorderinfo

searchitem

searchorder

searchitemdup

searchorderdup

getbibliosummary,

searchbiblio

getbiblioinfo,listbibliodbfroms,getsystemparameter,

~~~
2024/1/29
Borrow() API 中从册记录中读取信息验证当前读者证条码号(GetBorrowerBarcode())要考虑双链变化为 refID 以后的兼容性

册记录中 borrower 元素的内容，改为写入 @refID:xxxx。以前的 证条码号形态 依然有效，注意使用的时候加以判断

Borrow() API 返回的 BorrowInfo 结构中，strItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
*** 注意验证内务等前端的适应性


读者记录中 borrows/borrow 元素中，增加了一个 refID 属性，值为册记录的参考 ID。原有的 barcode 属性依然有效，是册条码号


Borrow() API 的操作日志记录，增加了一个 readerRefID 元素，里面是读者参考 ID。原有的 readerBarcode 元素没有变化，内容依然是读者证条码号
... 增加了一个 itemRefID 元素，里面是册参考 ID。原有的 itemBarcode 元素不变，内容依然是册条码号(少量可能是 @refID:xxx 形态)


~~~
Return() API 返回的 ReturnInfo 结构中，ItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
... Borrower 字段的内容增加了一种可能性 @refID:xxx 形态
*** 注意验证内务等前端的适应性

Return() API 的操作日志记录，增加一个 readerRefID 元素。
... 增加了一个 itemRefID 元素。

~~~
Reservation() API 中，预约时对册记录的 reservations/request/@reader 属性中写入的可能是证条码号或 @refID:xxx 形态

预约队列记录中增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

Reservation() API 的操作日志记录中，增加了一个 itemRefIdList 元素。原有 itemBarcodeList 元素依然有效
... 增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

~~~
读者记录中 reservations/request 元素的 arrivedItemBarcode 属性，可能是册条码号，也可能是 @refID:xxx 形态

~~~
根据操作日志记录重建 mongodb 借阅历史库的冒烟测试

~~~
重新检查日志前滚中对借还相关的日志动作的处理，要适应新旧两种日志格式

~~~
日志记录的 version 变化

~~~
检查预约到书记录的时候，如果发现相关的读者记录或册记录已经不存在，要写入错误日志以后，
继续向后通知下一个读者。
类似地，删除读者记录的时候，要检查有没有相关的到书状态的预约到书记录，如果有，
要做通知下一个读者处理。
删除册记录的时候，也要进行类似检查，看看怎么处理合适。

~~~
日志恢复过程中，要关注当前是否启用了 mongodb 出纳历史库。如果启用了，要和平时一样，
把每一笔恢复的日志动作，兑现到加入 mongodb 出纳历史库。这里可以沿用平时的机制和函数。


~~~
***
测试验证读者身份登录
读者身份使用 SearchCharging() API 只允许用读者参考 ID 查询。建议增加可以用册参考 ID 查询，但要(过滤)限定只返回这个读者(针对这一册图书)的借阅历史
临时的SessionInfo对象，模拟内部调用，需要统一函数。解决写入操作日志时 operator 为空的问题
读者身份登录进行借书还书操作。包括个人书斋情形
制造一条读者记录，证条码号字段为空，用参考 ID 登录应该成功
用这条没有证条码号的读者记录进行借还等等测试，应该成功


~~~
读者记录中 overdue 元素增加 refID 属性，内容为超期册的参考 ID
违约金记录增加 itemRefID 元素，内容为超期册的参考 ID
注意违约金记录中的 itemBarcode 元素内容可能是 @refID:xxx 形态，较早版本就已经是这样了

Amerce() API 的 rollback 功能需要冒烟测试一下

~~~
当前滚经过的日志记录明确表明一个书目库或者读者库被删除(并且也确实兑现了删除)，那么此后再遇到
需要临时创建这个数据库，就可以考虑态度为不予理会了。但注意，后面可能又有新的日志记录表明创建了这个数据库，则不予理会的作用域会停止起作用。

~~~
理论上来说，如果从任何一个点开始前滚(注: 此前没有从大备份恢复过，而是直接从全新安装开始)
先要自动向较早时间回溯，找到所有的创建和变更、删除数据库的动作，并据此构造出全部数据库
以后，再启动前滚，才是正确的做法。
不过，可能会遇到较早版本的日志记录中缺乏有关数据库的动作记录的问题。

~~~
setUser 操作日志动作是否要增加前滚实现?
修改读者密码的动作是否要前滚实现?
OPAC 显示格式的 library.xml 中配置部分需要前滚兑现么？(setSystemParameter 动作已经兑现)
dp2library 安装时创建的三个辅助数据库(违约金、预约到书、消息)，日志前滚时候是否兑现重建的动作? (已经兑现)

~~~
版本升级时，如果没有配置 mongodb 相关参数，则升级批处理依然要进行，
要把为读者记录和册记录添加 refID 元素的动作写入操作日志文件 (已经兑现)

~~~
日志恢复功能可以增加跳过点(范围)、终止点参数。
内务修改数据库的对话框增加一个 checkbox “锁定数据库名关系”或者叫“数据库名联动”

~~~
日志恢复在前滚兑现创建数据库、修改数据库配置文件动作的时候，要专门保护每个数据库(物理库)的 keys 配置文件。
做到虽然 keys 配置文件修改了，但不进入内存发生作用，实际上起作用的内存内容依然是这个数据库的 tempaletes 中对应的 keys 配置文件，
也就是说代表了最新的检索点配置。这样做的原因是，检索点关系到日志前滚过程中的借还等等动作兑现，而这些动作是高度依赖一些基本检索点的，
如果这些检索点配置修改不当，会影响到日志前滚本身功能的顺利进行。第二个原因，是 keys 配置文件一旦修改兑现装入内存，是不是还要马上进
行全库的检索点重建，这也是相当头疼的一个问题。

可以考虑在日志前滚结束之前，整体把这些过程中被 pending 的配置文件装载兑现到内存，并提醒操作者进行一次日志重建操作。

~~~
RecoverReturn() 中的 读者 XML 记录 clipping 处理

SetReaderInfo() 中针对参考 ID 的处理

临时创建读者库时候，对于推测的馆代码要警告一下，提醒操作者(在日志恢复完成后留意)核实

~~~
册记录的参考 ID 修改后，如果其 borrower 元素有值，要自动修改相关读者记录里面的 borrow 元素的 refID 属性

~~~
SetReaderInfo() 导致需要自动修改相关的册记录，但中途报错，这时读者记录已经被修改了，部分册记录已经被修改、另外一部分册记录还没有来得及修改，操作日志也没有写入。
需要改进为具备事务特性，如果中途放弃，则所有相关记录要还原到最初状态。
另外一个问题就是此时的读者记录加锁问题，要把证条码号字符串和参考 ID 字符串用于加锁这两种方式统一为一种方式才行

~~~
SetReaderInfo() 的 change 动作和 changereaderbarcode 动作到底有什么区别？
changereaderbarcode 动作是否能修改除了 barcode 元素以外的其它元素？
(注: changestate 动作是只能修改 state 元素的。要让 changereaderbarcode 动作和 changestate 动作的命名习惯保持一致)

~~~
注意检查 skipOperLog 的时候，也要跳过写入统计指标的语句

~~~
记到控件增加重新排列选定的期格子的功能。指按照选定的每年多少期方案重排(定位)格子的出版时间。

册记录的出版时间和期记录的出版时间是锁定的关系。但当期记录修改后，前端或者后端
应当自动修改所有相关册的出版时间，比较麻烦。可以考虑为册记录增加一种链接机制，
链接到期记录的参考 ID。这样每当期记录的出版时间修改的时候，册记录不用修改。
这时候，册记录的出版时间就应当默认期记录的出版时间，可以考虑把册记录的
publishTime 字段改为记录期记录的参考 ID。这样建立链接关系的同时，也去掉了
显式存储出版时间(这样就迫使使用关联的期记录的出版时间)。
但册记录少了这个出版时间以后，检索就成了一个问题。要把检索出版时间的动作转变
为检索一个符合这个时间的期参考 ID，也是一个新的麻烦。可以再思考思考看看是否还有更佳的
其它方案。

当内务用分馆账户身份登录使用的时候，到底是可以修改期记录(虽然不允许修改期记录
的出版时间字段)，还是不让修改，需要明确一下。期刊记到图形界面也要禁止
这种身份修改内存中的期记录的出版时间，因为如果允许修改，到保存的时候也会报错，
并且期不允许保存，册允许保存，会造成数据不一致。

另外一种策略是，实现期记录和册记录修改纳入同一个事务的能力。这样一旦期记录
没有保存成功，确保册记录也不会保存或者保存了会回滚。

~~~
日志恢复任务开始的时候，检查一下 app.vdbs 是否为 null，如果为 null 则报错拒绝进行日志恢复。

~~~
SetBiblioInfo() API 的 change 动作，遇到确定的路径，原记录不存在的情况，
是否应该直接报错。如果改变代码可能会引起前端兼容性问题，如何检查前端和回归测试？
比如故意背后删除一条书目记录，然后让内务种册窗用修改方式保存回去，观察
内务的报错，看看是否要改进内务。
另外，评估一下对于导入覆盖到书目库的功能模块是否会产生兼容性影响。

读者记录不允许这样做的原因是，如果允许了，可能会造成读者记录密码莫名其妙丢失
的安全性问题。看看书目记录是否也有类似问题。

~~~
MoveReaderInfo() API 目前的处理方法没有考虑当前账户对读者记录中的
字段修改权限。应改进为新旧记录(按照权限规则)合并后再写入。

~~~
小结：
SetBiblioInfo() change 动作，在遇到原记录不存在的时候，改变了语义，
现在是缺省报错返回(并返回错误码 NotFound)，需要检查前端兼容性

SetEntities() change 动作，在遇到原记录不存在的时候，改变了语义，
现在是缺省报错返回(并返回错误码 NotFound)，需要检查前端兼容性

SetOrders() 等 change 动作，在遇到原记录不存在的时候，改变了语义，
现在是缺省报错返回(并返回错误码 NotFound)，需要检查前端兼容性

这三类 API 的前端兼容性问题可以通过在 style 中增加 ifNotExist:continue 来解决。
但注意，原记录不存在，等于 operation 元素(create动作)就没有了，要考虑补齐
(用当天日期添加一个 create 动作的 operation 元素)。其它元素缺乏后的
副作用待评估

SetBiblioInfo() new 动作，在遇到原记录存在的时候，改变了语义，
现在是缺省报错返回(并返回错误码 AlreadyExist)，需要检查前端兼容性。
前端的兼容性问题可以通过在 style 中增加 ifExist:continue 来解决。

~~~
http://zing.z3950.org/srw/bath/2.0/
The Bath Profile for SRW, version 2.0

https://www.ukoln.ac.uk/interop-focus/activities/z3950/int_profile/bath/draft/stable1.html
The Bath Profile:
An International Z39.50 Specification
for Library Applications and Resource Discovery

~~~
GetReaderInfo() 也要有一种 force style，可以下载备份包括 password 元素的数据；
然后 SetReaderInfo() 的 force style 正好可以恢复这些数据，包括恢复 password 元素。
要求无论是 new 还是 change 动作都能恢复(指 force style)

~~~
无论 action 是 new 还是 change，只要原记录不存在，写入 operation 元素就
按照写入 create 动作来处理；只要原记录存在，就按照写入 change(modified) 动作处理。
这是说非 force 的情况。

~~~
CopyBiblioInfo() API 中对 997 查重的代码要审查一下。

~~~
GetBiblioInfo() API 和 SetBiblioInfo() API 联合使用的时候，如果一个账户
定义的 MARC 字段权限，是写范围大于读范围，就会造成一些字段在往返(读出/保存)
以后丢失。应该能识别这种情况，并在写入的时候报错说权限定义不合适。

~~~
可以用跳过 SQL 检索语句的方法，来 Profile 了解其它环节的高 CPU 耗用的环节，优化代码执行速度
最终用内务的组合检索(批检索)来验证提速效果