
Login() API 的 strParameters 参数里面可以包含 clientip 子参数

但因为在 ChannelPool 使用方式下，寻找空闲通道是按照 userName 来匹配的。
可能得到一根 userName 匹配，但用过的 clientIP 和当前 clientIP 并不相同。
这时候如果再分配一根新通道，比较浪费。最好是复用这根通道。
那么就需要有一个 API 可以动态设置通道的 clientIP。dp2library 响应这个
“修改 clientIP”的请求时，要像第一次创建通道时一样，检查这个 clientIP 所对应
的总通道数是否超过了配额，如果超过了则出错返回；如果没有超过则成功返回(返回前要增量所请求的 clientIP 的配额，减量一次被改掉的原 clientIP 的配额)。

有时候也可以考虑为 Login() API 的 clientip 子参数使用一个虚拟的 IP 地址字符串，例如
#opac，表示这些全都都是 dp2OPAC 发起的请求，算作同一个 IP 地址。

还有一个办法就是前端，使用 LibraryChannel 的时候，前端自己约束自己，保证所用
的通道数不超过一个配额。

order权限
囊括了
getitemifo

getorderinfo

getissueinfo

setorderinfo

searchitem

searchorder

searchitemdup

searchorderdup

getbibliosummary,

searchbiblio

getbiblioinfo,listbibliodbfroms,getsystemparameter,

~~~
2024/1/29
Borrow() API 中从册记录中读取信息验证当前读者证条码号(GetBorrowerBarcode())要考虑双链变化为 refID 以后的兼容性

册记录中 borrower 元素的内容，改为写入 @refID:xxxx。以前的 证条码号形态 依然有效，注意使用的时候加以判断

Borrow() API 返回的 BorrowInfo 结构中，strItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
*** 注意验证内务等前端的适应性


读者记录中 borrows/borrow 元素中，增加了一个 refID 属性，值为册记录的参考 ID。原有的 barcode 属性依然有效，是册条码号


Borrow() API 的操作日志记录，增加了一个 readerRefID 元素，里面是读者参考 ID。原有的 readerBarcode 元素没有变化，内容依然是读者证条码号
... 增加了一个 itemRefID 元素，里面是册参考 ID。原有的 itemBarcode 元素不变，内容依然是册条码号(少量可能是 @refID:xxx 形态)


~~~
Return() API 返回的 ReturnInfo 结构中，ItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
... Borrower 字段的内容增加了一种可能性 @refID:xxx 形态
*** 注意验证内务等前端的适应性

Return() API 的操作日志记录，增加一个 readerRefID 元素。
... 增加了一个 itemRefID 元素。

~~~
Reservation() API 中，预约时对册记录的 reservations/request/@reader 属性中写入的可能是证条码号或 @refID:xxx 形态

预约队列记录中增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

Reservation() API 的操作日志记录中，增加了一个 itemRefIdList 元素。原有 itemBarcodeList 元素依然有效
... 增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

~~~
读者记录中 reservations/request 元素的 arrivedItemBarcode 属性，可能是册条码号，也可能是 @refID:xxx 形态

~~~
根据操作日志记录重建 mongodb 借阅历史库的冒烟测试

~~~
重新检查日志前滚中对借还相关的日志动作的处理，要适应新旧两种日志格式

~~~
日志记录的 version 变化