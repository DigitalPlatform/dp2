
Login() API 的 strParameters 参数里面可以包含 clientip 子参数

但因为在 ChannelPool 使用方式下，寻找空闲通道是按照 userName 来匹配的。
可能得到一根 userName 匹配，但用过的 clientIP 和当前 clientIP 并不相同。
这时候如果再分配一根新通道，比较浪费。最好是复用这根通道。
那么就需要有一个 API 可以动态设置通道的 clientIP。dp2library 响应这个
“修改 clientIP”的请求时，要像第一次创建通道时一样，检查这个 clientIP 所对应
的总通道数是否超过了配额，如果超过了则出错返回；如果没有超过则成功返回(返回前要增量所请求的 clientIP 的配额，减量一次被改掉的原 clientIP 的配额)。

有时候也可以考虑为 Login() API 的 clientip 子参数使用一个虚拟的 IP 地址字符串，例如
#opac，表示这些全都都是 dp2OPAC 发起的请求，算作同一个 IP 地址。

还有一个办法就是前端，使用 LibraryChannel 的时候，前端自己约束自己，保证所用
的通道数不超过一个配额。

order权限
囊括了
getitemifo

getorderinfo

getissueinfo

setorderinfo

searchitem

searchorder

searchitemdup

searchorderdup

getbibliosummary,

searchbiblio

getbiblioinfo,listbibliodbfroms,getsystemparameter,

~~~
2024/1/29
Borrow() API 中从册记录中读取信息验证当前读者证条码号(GetBorrowerBarcode())要考虑双链变化为 refID 以后的兼容性

册记录中 borrower 元素的内容，改为写入 @refID:xxxx。以前的 证条码号形态 依然有效，注意使用的时候加以判断

Borrow() API 返回的 BorrowInfo 结构中，strItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
*** 注意验证内务等前端的适应性


读者记录中 borrows/borrow 元素中，增加了一个 refID 属性，值为册记录的参考 ID。原有的 barcode 属性依然有效，是册条码号


Borrow() API 的操作日志记录，增加了一个 readerRefID 元素，里面是读者参考 ID。原有的 readerBarcode 元素没有变化，内容依然是读者证条码号
... 增加了一个 itemRefID 元素，里面是册参考 ID。原有的 itemBarcode 元素不变，内容依然是册条码号(少量可能是 @refID:xxx 形态)


~~~
Return() API 返回的 ReturnInfo 结构中，ItemBarcode 字段的内容可能是册条码号，也可能是 @refID:xxx 形态
... Borrower 字段的内容增加了一种可能性 @refID:xxx 形态
*** 注意验证内务等前端的适应性

Return() API 的操作日志记录，增加一个 readerRefID 元素。
... 增加了一个 itemRefID 元素。

~~~
Reservation() API 中，预约时对册记录的 reservations/request/@reader 属性中写入的可能是证条码号或 @refID:xxx 形态

预约队列记录中增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

Reservation() API 的操作日志记录中，增加了一个 itemRefIdList 元素。原有 itemBarcodeList 元素依然有效
... 增加了一个 readerRefID 元素。原有 readerBarcode 元素依然有效

~~~
读者记录中 reservations/request 元素的 arrivedItemBarcode 属性，可能是册条码号，也可能是 @refID:xxx 形态

~~~
根据操作日志记录重建 mongodb 借阅历史库的冒烟测试

~~~
重新检查日志前滚中对借还相关的日志动作的处理，要适应新旧两种日志格式

~~~
日志记录的 version 变化

~~~
检查预约到书记录的时候，如果发现相关的读者记录或册记录已经不存在，要写入错误日志以后，
继续向后通知下一个读者。
类似地，删除读者记录的时候，要检查有没有相关的到书状态的预约到书记录，如果有，
要做通知下一个读者处理。
删除册记录的时候，也要进行类似检查，看看怎么处理合适。

~~~
日志恢复过程中，要关注当前是否启用了 mongodb 出纳历史库。如果启用了，要和平时一样，
把每一笔恢复的日志动作，兑现到加入 mongodb 出纳历史库。这里可以沿用平时的机制和函数。


~~~
***
测试验证读者身份登录
读者身份使用 SearchCharging() API 只允许用读者参考 ID 查询。建议增加可以用册参考 ID 查询，但要(过滤)限定只返回这个读者(针对这一册图书)的借阅历史
临时的SessionInfo对象，模拟内部调用，需要统一函数。解决写入操作日志时 operator 为空的问题
读者身份登录进行借书还书操作。包括个人书斋情形
制造一条读者记录，证条码号字段为空，用参考 ID 登录应该成功
用这条没有证条码号的读者记录进行借还等等测试，应该成功


~~~
读者记录中 overdue 元素增加 refID 属性，内容为超期册的参考 ID
违约金记录增加 itemRefID 元素，内容为超期册的参考 ID
注意违约金记录中的 itemBarcode 元素内容可能是 @refID:xxx 形态，较早版本就已经是这样了

Amerce() API 的 rollback 功能需要冒烟测试一下

~~~
当前滚经过的日志记录明确表明一个书目库或者读者库被删除(并且也确实兑现了删除)，那么此后再遇到
需要临时创建这个数据库，就可以考虑态度为不予理会了。但注意，后面可能又有新的日志记录表明创建了这个数据库，则不予理会的作用域会停止起作用。

~~~
理论上来说，如果从任何一个点开始前滚(注: 此前没有从大备份恢复过，而是直接从全新安装开始)
先要自动向较早时间回溯，找到所有的创建和变更、删除数据库的动作，并据此构造出全部数据库
以后，再启动前滚，才是正确的做法。
不过，可能会遇到较早版本的日志记录中缺乏有关数据库的动作记录的问题。

~~~
setUser 操作日志动作是否要增加前滚实现?
修改读者密码的动作是否要前滚实现?
OPAC 显示格式的 library.xml 中配置部分需要前滚兑现么？(setSystemParameter 动作已经兑现)
dp2library 安装时创建的三个辅助数据库(违约金、预约到书、消息)，日志前滚时候是否兑现重建的动作? (已经兑现)

~~~
版本升级时，如果没有配置 mongodb 相关参数，则升级批处理依然要进行，
要把为读者记录和册记录添加 refID 元素的动作写入操作日志文件 (已经兑现)

~~~
日志恢复功能可以增加跳过点(范围)、终止点参数。
内务修改数据库的对话框增加一个 checkbox “锁定数据库名关系”或者叫“数据库名联动”

~~~
日志恢复在前滚兑现创建数据库、修改数据库配置文件动作的时候，要专门保护每个数据库(物理库)的 keys 配置文件。
做到虽然 keys 配置文件修改了，但不进入内存发生作用，实际上起作用的内存内容依然是这个数据库的 tempaletes 中对应的 keys 配置文件，
也就是说代表了最新的检索点配置。这样做的原因是，检索点关系到日志前滚过程中的借还等等动作兑现，而这些动作是高度依赖一些基本检索点的，
如果这些检索点配置修改不当，会影响到日志前滚本身功能的顺利进行。第二个原因，是 keys 配置文件一旦修改兑现装入内存，是不是还要马上进
行全库的检索点重建，这也是相当头疼的一个问题。

可以考虑在日志前滚结束之前，整体把这些过程中被 pending 的配置文件装载兑现到内存，并提醒操作者进行一次日志重建操作。

~~~
RecoverReturn() 中的 读者 XML 记录 clipping 处理

SetReaderInfo() 中针对参考 ID 的处理

临时创建读者库时候，对于推测的馆代码要警告一下，提醒操作者(在日志恢复完成后留意)核实

~~~
册记录的参考 ID 修改后，如果其 borrower 元素有值，要自动修改相关读者记录里面的 borrow 元素的 refID 属性

~~~
SetReaderInfo() 导致需要自动修改相关的册记录，但中途报错，这时读者记录已经被修改了，部分册记录已经被修改、另外一部分册记录还没有来得及修改，操作日志也没有写入。
需要改进为具备事务特性，如果中途放弃，则所有相关记录要还原到最初状态。
另外一个问题就是此时的读者记录加锁问题，要把证条码号字符串和参考 ID 字符串用于加锁这两种方式统一为一种方式才行

~~~
SetReaderInfo() 的 change 动作和 changereaderbarcode 动作到底有什么区别？
changereaderbarcode 动作是否能修改除了 barcode 元素以外的其它元素？
(注: changestate 动作是只能修改 state 元素的。要让 changereaderbarcode 动作和 changestate 动作的命名习惯保持一致)

~~~
注意检查 skipOperLog 的时候，也要跳过写入统计指标的语句