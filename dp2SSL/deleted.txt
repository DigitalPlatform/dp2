

        void SubmitCheckInOut(bool clearPatron = true, bool silence = false)
        {
            // TODO: 如果当前没有读者身份，则当作初始化处理，将书柜内的全部图书做还书尝试；被拿走的图书记入本地日志(所谓无主操作)
            // TODO: 注意还书，也就是往书柜里面放入图书，是不需要具体读者身份就可以提交的

            // TODO: 属于 free 类型的门里面的图书不要参与处理

            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in ShelfData.Adds)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo { Entity = entity, Action = "return" });
            }
            foreach (var entity in ShelfData.Removes)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo { Entity = entity, Action = "borrow" });
            }

            if (actions.Count == 0)
                return;

            ProgressWindow progress = null;
            string patron_name = "";
            patron_name = _patron.PatronName;

            if (silence == false)
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress = new ProgressWindow();
                    progress.MessageText = "正在处理，请稍候 ...";
                    progress.Owner = Application.Current.MainWindow;
                    progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    progress.Closed += Progress_Closed;
                    progress.Width = Math.Min(700, this.ActualWidth);
                    progress.Height = Math.Min(500, this.ActualHeight);
                    progress.Show();
                    AddLayer();
                }));
            }

            // 先尽量执行还书请求，再报错说无法进行借书操作(记入错误日志)
            MessageDocument doc = new MessageDocument();

            bool patron_filled = false;

            // 检查读者卡状态是否 OK
            if (IsPatronOK("open", out string check_message) == false)
            {
                /*
                if (string.IsNullOrEmpty(check_message))
                    check_message = $"读卡器上的当前读者卡状态不正确。无法进行 checkin/out 操作";

                DisplayError(ref progress, check_message);
                return;
                */
            }
            else
                patron_filled = true;

            LibraryChannel channel = App.CurrentApp.GetChannel();
            try
            {
                // ClearEntitiesError();

                if (progress != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.ProgressBar.Value = 0;
                        progress.ProgressBar.Minimum = 0;
                        progress.ProgressBar.Maximum = actions.Count;
                    }));
                }

                // TODO: 准备工作：把涉及到的 Entity 对象的字段填充完整
                // 检查 PII 是否都具备了

                int skip_count = 0;
                int success_count = 0;
                List<string> errors = new List<string>();
                List<string> borrows = new List<string>();
                List<string> returns = new List<string>();
                List<string> warnings = new List<string>();
                foreach (ActionInfo info in actions)
                {
                    string action = info.Action;
                    Entity entity = info.Entity;

                    string action_name = "借书";
                    if (action == "return")
                        action_name = "还书";
                    else if (action == "renew")
                        action_name = "续借";

                    // 借书操作必须要有读者卡。(还书和续借，可要可不要)
                    if (action == "borrow")
                    {
                        if (patron_filled == false)
                        {
                            // 界面警告
                            errors.Add($"册 '{entity.PII}' 无法进行借书请求");
                            // 写入错误日志
                            WpfClientInfo.WriteInfoLog($"册 '{entity.PII}' 无法进行借书请求");
                            continue;
                        }

                        if (string.IsNullOrEmpty(_patron.Barcode))
                        {
                            DisplayError(ref progress, $"请先在读卡器上放好读者卡，再进行{action_name}");
                            return;
                        }
                    }

                    long lRet = 0;
                    string strError = "";
                    string[] item_records = null;
                    string[] biblio_records = null;
                    BorrowInfo borrow_info = null;

                    if (action == "borrow" || action == "renew")
                    {
                        /*
                        if (action == "borrow" && entity.State == "borrowed")
                        {
                            entity.SetError($"本册是外借状态。{action_name}操作被忽略", "yellow");
                            skip_count++;
                            continue;
                        }
                        if (action == "renew" && entity.State == "onshelf")
                        {
                            entity.SetError($"本册是在馆状态。{action_name}操作被忽略 (只有处于外借状态的册才能进行续借)", "yellow");
                            skip_count++;
                            continue;
                        }
                        */
                        // TODO: 智能书柜要求强制借书。如果册操作前处在被其他读者借阅状态，要自动先还书再进行借书

                        entity.Waiting = true;
                        lRet = channel.Borrow(null,
                            action == "renew",
                            _patron.Barcode,
                            entity.PII,
                            entity.ItemRecPath,
                            false,
                            null,
                            "item,reader,biblio,overflowable", // style,
                            "xml", // item_format_list
                            out item_records,
                            "xml",
                            out string[] reader_records,
                            "summary",
                            out biblio_records,
                            out string[] dup_path,
                            out string output_reader_barcode,
                            out borrow_info,
                            out strError);

                    }
                    else if (action == "return")
                    {
                        /*
                        if (entity.State == "onshelf")
                        {
                            entity.SetError($"本册是在馆状态。{action_name}操作被忽略", "yellow");
                            skip_count++;
                            continue;
                        }
                        */

                        /*
                        // TODO: 增加检查 EAS 现有状态功能，如果已经是 true 则不用修改，后面 API 遇到出错后也不要回滚 EAS
                        // return 操作，提前修改 EAS
                        // 注: 提前修改 EAS 的好处是比较安全。相比 API 执行完以后再修改 EAS，提前修改 EAS 成功后，无论后面发生什么，读者都无法拿着这本书走出门禁
                        {
                            var result = SetEAS(entity.UID, entity.Antenna, action == "return");
                            if (result.Value == -1)
                            {
                                entity.SetError($"{action_name}时修改 EAS 动作失败: {result.ErrorInfo}", "red");
                                errors.Add($"册 '{entity.PII}' {action_name}时修改 EAS 动作失败: {result.ErrorInfo}");
                                continue;
                            }
                        }
                        */
                        // 智能书柜不使用 EAS 状态。可以考虑统一修改为 EAS Off 状态？

                        entity.Waiting = true;
                        lRet = channel.Return(null,
                            "return",
                            "", // _patron.Barcode,
                            entity.PII,
                            entity.ItemRecPath,
                            false,
                            "item,reader,biblio", // style,
                            "xml", // item_format_list
                            out item_records,
                            "xml",
                            out string[] reader_records,
                            "summary",
                            out biblio_records,
                            out string[] dup_path,
                            out string output_reader_barcode,
                            out ReturnInfo return_info,
                            out strError);
                    }

                    if (progress != null)
                    {
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            progress.ProgressBar.Value++;
                        }));
                    }

                    if (biblio_records != null && biblio_records.Length > 0)
                        entity.Title = biblio_records[0];

                    string title = entity.PII;
                    if (string.IsNullOrEmpty(entity.Title) == false)
                        title += " (" + entity.Title + ")";

                    {
                        // 把 _adds 和 _removes 归入 _all
                        // 一边处理一边动态修改 _all?
                        if (action == "return")
                            ShelfData.Add(ShelfData.All, entity);
                        else
                            ShelfData.Remove(ShelfData.All, entity);

                        ShelfData.Remove(ShelfData.Adds, entity);
                        ShelfData.Remove(ShelfData.Removes, entity);
                    }

                    string resultType = "succeed";
                    if (lRet == -1)
                        resultType = "error";
                    else if (lRet == 1)
                        resultType = "information";
                    MessageItem messageItem = new MessageItem
                    {
                        Operation = action,
                        ResultType = resultType,
                        ErrorCode = channel.ErrorCode.ToString(),
                        ErrorInfo = strError,
                        Entity = entity,
                    };
                    doc.Add(messageItem);

                    // 微调
                    if (lRet == 0 && action == "return")
                        messageItem.ErrorInfo = "";

                    if (lRet == -1)
                    {
                        /*
                        // return 操作如果 API 失败，则要改回原来的 EAS 状态
                        if (action == "return")
                        {
                            var result = SetEAS(entity.UID, entity.Antenna, false);
                            if (result.Value == -1)
                                strError += $"\r\n并且复原 EAS 状态的动作也失败了: {result.ErrorInfo}";
                        }
                        */

                        if (action == "return")
                        {
                            if (channel.ErrorCode == ErrorCode.NotBorrowed)
                            {
                                // TODO: 这里不知是普通状态还是 warning 合适。warning 是否比较强烈了
                                messageItem.ResultType = "warning";
                                messageItem.ErrorCode = ErrorCode.NotBorrowed.ToString();
                                // 界面警告
                                warnings.Add($"册 '{title}' (尝试还书时发现未曾被借出过): {strError}");
                                // 写入错误日志
                                WpfClientInfo.WriteInfoLog($"读者 {_patron.NameSummary} 尝试还回册 '{title}' 时: {strError}");
                                continue;
                            }
                        }

                        entity.SetError($"{action_name}操作失败: {strError}", "red");
                        // TODO: 这里最好用 title
                        errors.Add($"册 '{title}': {strError}");
                        continue;
                    }

                    if (action == "borrow")
                    {
                        if (borrow_info.Overflows != null && borrow_info.Overflows.Length > 0)
                        {
                            // 界面警告
                            // TODO: 可以考虑归入 overflows 单独语音警告处理。语音要简洁。详细原因可出现在文字警告中
                            // warnings.Add($"册 '{title}' (借书操作发生溢出，请于当日内还书): {string.Join("; ", borrow_info.Overflows)}");

                            // TODO: 详细原因文字可否用稍弱的字体效果来显示？
                            messageItem.ErrorInfo = $"借书操作超越许可，请将本册放回书柜。详细原因： {string.Join("; ", borrow_info.Overflows)}";
                            messageItem.ResultType = "warning";
                            messageItem.ErrorCode = "overflow";
                            // 写入错误日志
                            WpfClientInfo.WriteInfoLog($"读者 {_patron.NameSummary} 借阅 '{title}' 时发生超越许可: {strError}");
                        }
                    }

                    if (action == "borrow")
                        borrows.Add(title);
                    if (action == "return")
                        returns.Add(title);

                    /*
                    // borrow 操作，API 之后才修改 EAS
                    // 注: 如果 API 成功但修改 EAS 动作失败(可能由于读者从读卡器上过早拿走图书导致)，读者会无法把本册图书拿出门禁。遇到此种情况，读者回来补充修改 EAS 一次即可
                    if (action == "borrow")
                    {
                        var result = SetEAS(entity.UID, entity.Antenna, action == "return");
                        if (result.Value == -1)
                        {
                            entity.SetError($"虽然{action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}", "yellow");
                            errors.Add($"册 '{entity.PII}' {action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}");
                        }
                    }
                    */

                    // 刷新显示
                    {
                        if (item_records?.Length > 0)
                            entity.SetData(entity.ItemRecPath, item_records[0]);

                        if (entity.Error != null)
                            continue;

                        string message = $"{action_name}成功";
                        if (lRet == 1 && string.IsNullOrEmpty(strError) == false)
                            message = strError;
                        entity.SetError(message,
                            lRet == 1 ? "yellow" : "green");
                        success_count++;
                        // 刷新显示。特别是一些关于借阅日期，借期，应还日期的内容
                    }
                }

                if (progress != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.ProgressBar.Visibility = Visibility.Collapsed;
                        // progress.ProgressBar.Value = progress.ProgressBar.Maximum;
                    }));
                }

                // 修改 borrowable
                // booksControl.SetBorrowable();

#if NO
                if (errors.Count > 0)
                {
                    // TODO: 成功和出错可能会同时存在

                    string error = StringUtil.MakePathList(errors, "\r\n");
                    string message = $"操作出错 {errors.Count} 个";
                    if (success_count > 0)
                        message += $"，成功 {success_count} 个";
                    if (skip_count > 0)
                        message += $" (另有 {skip_count} 个被忽略)";

                    if (errors.Count > 0)
                        message += $"\r\n出错:\r\n" + error;

                    DisplayError(ref progress, message);
                    App.CurrentApp.Speak(message);
                    return; // new NormalResult { Value = -1, ErrorInfo = StringUtil.MakePathList(errors, "; ") };
                }
                else
#endif
                {
#if NO
                    // 成功
                    string backColor = "green";
                    string message = "";

                    if (success_count > 0)
                        message = $"{patron_name} 操作成功 {success_count} 笔";
                    if (errors.Count > 0)
                    {
                        message += "\r\n";
                        message += $"操作出错 {errors.Count} 个";

                        backColor = "red";
                    }
                    if (warnings.Count > 0)
                    {
                        message += "\r\n";
                        message += $"操作警告 {warnings.Count} 个";

                        backColor = "yellow";
                    }

                    string speak = $"出纳完成";

                    /*
                    if (skip_count > 0)
                    {
                        message += "\r\n";
                        message += $" (另有 {skip_count} 笔被忽略)";
                    }

                    if (skip_count > 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"全部 {skip_count} 笔出纳操作被忽略";
                        speak = $"出纳失败";
                    }
                    if (skip_count == 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"请先把图书放到读卡器上，再进行 出纳 操作";
                        speak = $"出纳失败";
                    }
                    */

                    if (errors.Count > 0)
                        message += $"\r\n出错:\r\n" + MakeList(errors);

                    if (warnings.Count > 0)
                        message += $"\r\n警告:\r\n" + MakeList(warnings);

                    if (returns.Count > 0)
                        message += $"\r\n还书:\r\n" + MakeList(returns);

                    if (borrows.Count > 0)
                        message += $"\r\n借书:\r\n" + MakeList(borrows);
#endif
                    string speak = "";
                    if (progress != null)
                    {
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            // DisplayError(ref progress, message, backColor);
                            progress.MessageDocument = doc.BuildDocument(patron_name, 18, out speak);
                            progress = null;
                        }));
                    }

                    // 重新装载读者信息和显示
                    // DoorItem.DisplayCount(_all, _adds, _removes, App.CurrentApp.Doors);
                    ShelfData.RefreshCount();

                    App.CurrentApp.Speak(speak);
                }

                return; // new NormalResult { Value = success_count };
            }
            finally
            {
                App.CurrentApp.ReturnChannel(channel);
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    if (progress != null)
                        progress.Close();
                }));
                if (clearPatron)
                    PatronClear(false);
            }
        }


		        // TODO: 报错信息尝试用 FlowDocument 改造
        // 尝试进行一次还书操作
        void TryReturn(ProgressWindow progress,
            List<Entity> entities)
        {
            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in entities)
            {
                actions.Add(new ActionInfo { Entity = entity, Action = "return" });
            }

            LibraryChannel channel = App.CurrentApp.GetChannel();
            try
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress.ProgressBar.Value = 0;
                    progress.ProgressBar.Minimum = 0;
                    progress.ProgressBar.Maximum = actions.Count;
                }));

                // TODO: 准备工作：把涉及到的 Entity 对象的字段填充完整
                // 检查 PII 是否都具备了

                int skip_count = 0;
                int success_count = 0;
                List<string> errors = new List<string>();
                List<string> borrows = new List<string>();
                List<string> returns = new List<string>();
                foreach (ActionInfo info in actions)
                {
                    string action = info.Action;
                    Entity entity = info.Entity;

                    string action_name = "借书";
                    if (action == "return")
                        action_name = "还书";
                    else if (action == "renew")
                        action_name = "续借";

                    long lRet = 0;
                    string strError = "";
                    string[] item_records = null;
                    string[] biblio_records = null;

                    if (action == "return")
                    {
                        // 智能书柜不使用 EAS 状态。可以考虑统一修改为 EAS Off 状态？

                        entity.Waiting = true;
                        lRet = channel.Return(null,
                            "return",
                            "", // _patron.Barcode,
                            entity.PII,
                            entity.ItemRecPath,
                            false,
                            "item,reader,biblio", // style,
                            "xml", // item_format_list
                            out item_records,
                            "xml",
                            out string[] reader_records,
                            "summary",
                            out biblio_records,
                            out string[] dup_path,
                            out string output_reader_barcode,
                            out ReturnInfo return_info,
                            out strError);
                    }

                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.ProgressBar.Value++;
                    }));

                    if (biblio_records != null && biblio_records.Length > 0)
                        entity.Title = biblio_records[0];

                    string title = entity.PII;
                    if (string.IsNullOrEmpty(entity.Title) == false)
                        title += " (" + entity.Title + ")";

                    // TODO: 各种情况的返回值和错误码
                    if (lRet == -1)
                    {
                        /*
                        // return 操作如果 API 失败，则要改回原来的 EAS 状态
                        if (action == "return")
                        {
                            var result = SetEAS(entity.UID, entity.Antenna, false);
                            if (result.Value == -1)
                                strError += $"\r\n并且复原 EAS 状态的动作也失败了: {result.ErrorInfo}";
                        }
                        */

                        if (channel.ErrorCode == ErrorCode.NotBorrowed)
                        {

                        }
                        else
                        {
                            entity.SetError($"{action_name}操作失败: {strError}", "red");
                            // TODO: 这里最好用 title
                            errors.Add($"册 '{title}': {strError}");
                        }
                        continue;
                    }

                    if (action == "borrow")
                        borrows.Add(title);
                    if (action == "return")
                        returns.Add(title);

                    // TODO: 把 _adds 和 _removes 归入 _all
                    // 是否一边处理一边动态修改 _all?
                    if (action == "return")
                        ShelfData.Add(ShelfData.All, entity);
                    else
                        ShelfData.Remove(ShelfData.All, entity);

                    ShelfData.Remove(ShelfData.Adds, entity);
                    ShelfData.Remove(ShelfData.Removes, entity);

                    /*
                    // borrow 操作，API 之后才修改 EAS
                    // 注: 如果 API 成功但修改 EAS 动作失败(可能由于读者从读卡器上过早拿走图书导致)，读者会无法把本册图书拿出门禁。遇到此种情况，读者回来补充修改 EAS 一次即可
                    if (action == "borrow")
                    {
                        var result = SetEAS(entity.UID, entity.Antenna, action == "return");
                        if (result.Value == -1)
                        {
                            entity.SetError($"虽然{action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}", "yellow");
                            errors.Add($"册 '{entity.PII}' {action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}");
                        }
                    }
                    */

                    // 刷新显示
                    {
                        if (item_records?.Length > 0)
                            entity.SetData(entity.ItemRecPath, item_records[0]);

                        if (entity.Error != null)
                            continue;

                        string message = $"{action_name}成功";
                        if (lRet == 1 && string.IsNullOrEmpty(strError) == false)
                            message = strError;
                        entity.SetError(message,
                            lRet == 1 ? "yellow" : "green");
                        success_count++;
                        // 刷新显示。特别是一些关于借阅日期，借期，应还日期的内容
                    }
                }

                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress.ProgressBar.Visibility = Visibility.Collapsed;
                    // progress.ProgressBar.Value = progress.ProgressBar.Maximum;
                }));

                // 修改 borrowable
                // booksControl.SetBorrowable();

                if (errors.Count > 0)
                {
                    string error = StringUtil.MakePathList(errors, "\r\n");
                    string message = $"操作出错 {errors.Count} 个";
                    if (success_count > 0)
                        message += $"，成功 {success_count} 个";
                    if (skip_count > 0)
                        message += $" (另有 {skip_count} 个被忽略)";

                    if (errors.Count > 0)
                        message += $"\r\n出错:\r\n" + error;

                    DisplayError(ref progress, message);
                    App.CurrentApp.Speak(message);
                    return; // new NormalResult { Value = -1, ErrorInfo = StringUtil.MakePathList(errors, "; ") };
                }
                else
                {
                    /*
                    // 成功
                    string backColor = "green";
                    string message = $"{patron_name} 操作成功 {success_count} 笔";
                    string speak = $"出纳完成";

                    if (skip_count > 0)
                        message += $" (另有 {skip_count} 笔被忽略)";
                    if (skip_count > 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"全部 {skip_count} 笔出纳操作被忽略";
                        speak = $"出纳失败";
                    }
                    if (skip_count == 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"请先把图书放到读卡器上，再进行 出纳 操作";
                        speak = $"出纳失败";
                    }

                    if (returns.Count > 0)
                        message += $"\r\n还书:\r\n" + MakeList(returns);

                    if (borrows.Count > 0)
                        message += $"\r\n借书:\r\n" + MakeList(borrows);

                    DisplayError(ref progress, message, backColor);

                    // 重新装载读者信息和显示
                    // var task = FillPatronDetail(true);
                    this.doorControl.DisplayCount(_all, _adds, _removes);

                    App.CurrentApp.Speak(speak);
                    */
                }

                return; // new NormalResult { Value = success_count };
            }
            finally
            {
                App.CurrentApp.ReturnChannel(channel);
            }
        }


		        public void InitializeButtons(XmlDocument cfg_dom,
            List<DoorItem> items)
        {
            /*
            string cfg_filename = App.ShelfFilePath;
            XmlDocument cfg_dom = new XmlDocument();
            cfg_dom.Load(cfg_filename);
            */

            XmlNodeList shelfs = cfg_dom.DocumentElement.SelectNodes("shelf");

            this.grid.ColumnDefinitions.Clear();
            this.grid.RowDefinitions.Clear();

            // 获得一个 shelf 元素下 door 数量的最多那个
            int max_doors = 0;
            foreach (XmlElement shelf in shelfs)
            {
                int current = shelf.SelectNodes("door").Count;
                if (current > max_doors)
                    max_doors = current;
            }

            // int shelf_width = total_width / Math.Max(1, shelfs.Count);
            // int level_height = 100;
            bool rowDefinitionCreated = false;
            // 初始化 Definitions
            foreach (XmlElement shelf in shelfs)
            {
                this.grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(100) });

                // TODO: 这里要用具有最多 door 元素的 shelf 元素来获得数字
                if (rowDefinitionCreated == false)
                {
                    /*
                    XmlNodeList doors = shelf.SelectNodes("door");
                    // level_height = total_height / Math.Max(1, doors.Count);
                    foreach (XmlElement door in doors)
                    {
                        this.grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(100) });
                    }
                    */
                    for (int i = 0; i < max_doors; i++)
                    {
                        this.grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(100) });
                    }

                    rowDefinitionCreated = true;
                }
            }

            // 填充 Buttons
            int index = 0;
            int column = 0;
            foreach (XmlElement shelf in shelfs)
            {
                XmlNodeList doors = shelf.SelectNodes("door");
                int row = 0;
                foreach (XmlElement door in doors)
                {
                    string door_name = door.GetAttribute("name");

                    Button button = new Button
                    {
                        Name = $"button_{column}_{row}",
                        // Height = level_height,
                        // Content = door_name,
                    };

                    /*
                    var block = BuildTextBlock();
                    SetBlockText(block, door_name, "0", null, null);
                    */

                    var template = this.Resources["ButtonTemplate"];

                    // button.Children.Add(block);
                    button.SetValue(Button.TemplateProperty, template);
                    // button.SetValue(Grid.prop.ContentProperty, block);
                    button.SetValue(Grid.RowProperty, row);
                    button.SetValue(Grid.ColumnProperty, column);
                    button.Click += Button_Click;

                    /*
                    ParseLockString(door.GetAttribute("lock"), out string lockName, out int lockIndex);
                    ParseLockString(door.GetAttribute("antenna"), out string readerName, out int antenna);

                    var tag = new Door
                    {
                        Name = door_name,
                        LockName = lockName,
                        LockIndex = lockIndex,
                        ReaderName = readerName,
                        Antenna = antenna,
                        Button = button
                    };
                    */

                    button.DataContext = items[index++];

                    /*
                    _doors.Add(tag);

                    button.Tag = tag;
                    */
                    this.grid.Children.Add(button);
                    row++;
                }

                column++;
            }

            /*
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });

            Button button = new Button
            {
                Name = "button1",
                Height = 100,
                Content = "1",
            };
            button.SetValue(Grid.RowProperty, 0);
            //button.SetValue(Grid.ColumnProperty, 0);
            this.grid.Children.Add(button);
            */

            InitialSize();
        }


		        void SetSize(Size size)
        {
            double row_height = size.Height / Math.Max(1, this.grid.RowDefinitions.Count);
            foreach (var row in this.grid.RowDefinitions)
            {
                row.Height = new GridLength(row_height);
            }
            double column_width = size.Width / Math.Max(1, this.grid.ColumnDefinitions.Count);
            foreach (var column in this.grid.ColumnDefinitions)
            {
                column.Width = new GridLength(column_width);
            }
        }


		~~~~~~~~~~~

		        // 关门，或者更换读者的时候，向服务器提交出纳请求
        // parameters:
        //      clearPatron 操作完成后是否自动清除右侧的读者信息
        async Task SubmitCheckInOut(
            string strStyle = "clearPatron")
        {
            bool clearPatron = false;
            bool silence = false;

            if (StringUtil.IsInList("clearPatron", strStyle))
                clearPatron = true;
            if (StringUtil.IsInList("silence", strStyle))
                silence = true;
            bool verifyDoorClosing = StringUtil.IsInList("verifyDoorClosing", strStyle);

        REDO:
            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in ShelfData.Adds)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo
                {
                    Entity = entity,
                    Action = "return",
                    Operator = GetOperator()
                });
                // 没有更新的，才进行一次 transfer
                if (ShelfData.Find(ShelfData.Changes, entity.UID).Count == 0)
                {
                    actions.Add(new ActionInfo
                    {
                        Entity = entity,
                        Action = "transfer",
                        CurrentShelfNo = ShelfData.GetShelfNo(entity),
                        Operator = GetOperator()
                    });
                }
            }
            foreach (var entity in ShelfData.Changes)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                // 更新
                actions.Add(new ActionInfo
                {
                    Entity = entity,
                    Action = "transfer",
                    CurrentShelfNo = ShelfData.GetShelfNo(entity),
                    Operator = GetOperator()
                });
            }
            foreach (var entity in ShelfData.Removes)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo
                {
                    Entity = entity,
                    Action = "borrow",
                    Operator = GetOperator()
                });
            }

            if (actions.Count == 0)
                return;  // 没有必要处理

            // 关闭以前残留的对话框
            CloseDialogs();

            ProgressWindow progress = null;
            string patron_name = "";
            patron_name = _patron.PatronName;

            if (silence == false)
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress = new ProgressWindow();
                    progress.MessageText = "正在处理，请稍候 ...";
                    progress.Owner = Application.Current.MainWindow;
                    progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    progress.Closed += Progress_Closed;
                    progress.Width = Math.Min(700, this.ActualWidth);
                    progress.Height = Math.Min(500, this.ActualHeight);
                    progress.Show();
                    AddLayer();
                }));
            }

            // 检查门是否全关闭
            if (verifyDoorClosing && silence == false)
            {
                if (ShelfData.OpeningDoorCount > 0)
                {
                    // 检查门是否为关闭状态？
                    await Task.Run(() =>
                    {
                        while (ShelfData.OpeningDoorCount > 0)
                        {
                            // TODO: 如何中断？
                            //if (_initialCancelled)
                            //    break;
                            DisplayMessage(progress, "请关闭全部柜门，以完成请求", "yellow");
                            Thread.Sleep(1000);
                        }
                    });
                    // 确保全关闭后，回到开头重做
                    if (progress != null)
                        progress.Close();
                    goto REDO;
                }
            }

            bool patron_filled = false;

            // 检查读者卡状态是否 OK
            if (IsPatronOK("open", out string check_message) == false)
            {
                /*
                if (string.IsNullOrEmpty(check_message))
                    check_message = $"读卡器上的当前读者卡状态不正确。无法进行 checkin/out 操作";

                DisplayError(ref progress, check_message);
                return;
                */
            }
            else
                patron_filled = true;

            try
            {
                var result = ShelfData.SubmitCheckInOut(
                    (min, max, value) =>
                    {
                        if (progress != null)
                        {
                            Application.Current.Dispatcher.Invoke(new Action(() =>
                            {
                                if (min == -1 && max == -1 && value == -1)
                                    progress.ProgressBar.Visibility = Visibility.Collapsed;
                                if (min != -1)
                                    progress.ProgressBar.Minimum = min;
                                if (max != -1)
                                    progress.ProgressBar.Maximum = max;
                                if (value != -1)
                                    progress.ProgressBar.Value = value;
                            }));
                        }
                    },
                    //_patron.Barcode,
                    //_patron.PatronName,
                    actions,
                    patron_filled);
                if (result.Value == -1)
                {
                    DisplayError(ref progress, result.ErrorInfo);
                    return;
                }

                string speak = "";
                if (progress != null && result.Value == 1 && result.MessageDocument != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.MessageDocument = result.MessageDocument.BuildDocument(patron_name, 18, out speak);
                        MemoryDialog(progress); // 记住对话框，以便后面可以补充关闭
                        progress = null;
                    }));
                }

                if (string.IsNullOrEmpty(speak) == false)
                    App.CurrentApp.Speak(speak);
            }
            finally
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    if (progress != null)
                        progress.Close();
                }));
                if (clearPatron)
                    PatronClear(false);
            }
        }


		~~~~~~~~~

		        // 从 shelf.xml 配置文件中归纳出所有的天线编号
        public static string GetAntennaList()
        {
            if (ShelfCfgDom == null)
                return "";

            List<string> antenna_list = new List<string>();

            XmlNodeList doors = ShelfCfgDom.DocumentElement.SelectNodes("shelf/door");
            foreach (XmlElement door in doors)
            {
                DoorItem.ParseReaderString(door.GetAttribute("antenna"),
                    out string readerName,
                    out int antenna);
                antenna_list.Add(antenna.ToString());
            }

            StringUtil.RemoveDup(ref antenna_list, false);
            return StringUtil.MakePathList(antenna_list, "|");

            /*
            List<string> antenna_list = new List<string>();
            string cfg_filename = ShelfData.ShelfFilePath;
            XmlDocument cfg_dom = new XmlDocument();
            try
            {
                cfg_dom.Load(cfg_filename);

                XmlNodeList doors = cfg_dom.DocumentElement.SelectNodes("shelf/door");
                foreach (XmlElement door in doors)
                {
                    DoorItem.ParseLockString(door.GetAttribute("antenna"),
                        out string readerName,
                        out int antenna);
                    antenna_list.Add(antenna.ToString());
                }

                StringUtil.RemoveDup(ref antenna_list, false);
                return StringUtil.MakePathList(antenna_list, "|");
            }
            catch (FileNotFoundException)
            {
                return "";
            }
            catch (Exception ex)
            {
                this.SetError("cfg", $"装载配置文件 shelf.xml 时出现异常: {ex.Message}");
                return "";
            }
            */
        }


		~~~~~~~~~~~~~

		        // 向服务器提交 actions 中存储的全部出纳请求
        // parameters:
        //      clearPatron 操作完成后是否自动清除右侧的读者信息
        async Task SubmitCheckInOut(
            string strStyle = "")
        {
            bool silence = false;

            if (StringUtil.IsInList("silence", strStyle))
                silence = true;
            bool verifyDoorClosing = StringUtil.IsInList("verifyDoorClosing", strStyle);

        REDO:

            if (ShelfData.Actions.Count == 0)
                return;  // 没有必要处理

            // 关闭以前残留的对话框
            CloseDialogs();

            ProgressWindow progress = null;
            //string patron_name = "";
            //patron_name = _patron.PatronName;

            if (silence == false)
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress = new ProgressWindow();
                    progress.MessageText = "正在处理，请稍候 ...";
                    progress.Owner = Application.Current.MainWindow;
                    progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    progress.Closed += Progress_Closed;
                    progress.Width = Math.Min(700, this.ActualWidth);
                    progress.Height = Math.Min(500, this.ActualHeight);
                    progress.Show();
                    AddLayer();
                }));
            }

#if NO
            // 检查门是否全关闭
            if (verifyDoorClosing && silence == false)
            {
                if (ShelfData.OpeningDoorCount > 0)
                {
                    // 检查门是否为关闭状态？
                    await Task.Run(() =>
                    {
                        while (ShelfData.OpeningDoorCount > 0)
                        {
                            // TODO: 如何中断？
                            //if (_initialCancelled)
                            //    break;
                            DisplayMessage(progress, "请关闭全部柜门，以完成请求", "yellow");
                            Thread.Sleep(1000);
                        }
                    });
                    // 确保全关闭后，回到开头重做
                    if (progress != null)
                        progress.Close();
                    goto REDO;
                }
            }

#endif

#if NO
            bool patron_filled = false;

            // 检查读者卡状态是否 OK
            if (IsPatronOK("open", out string check_message) == false)
            {
                /*
                if (string.IsNullOrEmpty(check_message))
                    check_message = $"读卡器上的当前读者卡状态不正确。无法进行 checkin/out 操作";

                DisplayError(ref progress, check_message);
                return;
                */
            }
            else
                patron_filled = true;
#endif
            try
            {
                var result = ShelfData.SubmitCheckInOut(
                    (min, max, value) =>
                    {
                        if (progress != null)
                        {
                            Application.Current.Dispatcher.Invoke(new Action(() =>
                            {
                                if (min == -1 && max == -1 && value == -1)
                                    progress.ProgressBar.Visibility = Visibility.Collapsed;
                                if (min != -1)
                                    progress.ProgressBar.Minimum = min;
                                if (max != -1)
                                    progress.ProgressBar.Maximum = max;
                                if (value != -1)
                                    progress.ProgressBar.Value = value;
                            }));
                        }
                    },
                    //_patron.Barcode,
                    //_patron.PatronName,
                    ShelfData.Actions);
                if (result.Value == -1)
                {
                    DisplayError(ref progress, result.ErrorInfo);
                    return;
                }

                string speak = "";
                if (progress != null && result.Value == 1 && result.MessageDocument != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.MessageDocument = result.MessageDocument.BuildDocument(18, out speak);
                        MemoryDialog(progress); // 记住对话框，以便后面可以补充关闭
                        progress = null;
                    }));
                }

                if (string.IsNullOrEmpty(speak) == false)
                    App.CurrentApp.Speak(speak);
            }
            finally
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    if (progress != null)
                        progress.Close();
                }));
                //if (clearPatron)
                //    PatronClear(false);
            }
        }


		~~~~~~~~~~~~~~

		        // 启动后台任务。
        // 后台任务负责监视 RFID 中心的标签
        public static void Start(
            CancellationToken token)
        {
            Base.ShortWaitTime = TimeSpan.FromMilliseconds(10);
            Base.LongWaitTime = TimeSpan.FromMilliseconds(2000);
            Base.Start((channel) =>
            {
                // TODO: 看调用栈，如果是上层 GetState() 调用，就要免去检查 State 这一步
                if (_checkState)
                {
                    var result = channel.Object.GetState("");
                    if (result.Value == -1)
                        throw new Exception($"RFID 中心当前处于 {result.ErrorCode} 状态({result.ErrorInfo})");
                }
                channel.Started = true;

                channel.Object.EnableSendKey(false);
            },
            () =>
            {
                if (_pause == true)
                {
                    Base.TriggerSetError(null,
new SetErrorEventArgs
{
    Error = "RFID 功能已暂停"
});
                    return true;
                }

                if (string.IsNullOrEmpty(Base.Url))
                {
                    Base.TriggerSetError(null,
                        new SetErrorEventArgs
                        {
                            Error = "RFID 中心 URL 尚未配置(因此无法从 RFID 读卡器读取信息)"
                        });
                    return true;
                }

                return false;
            },
            (channel) =>
            {
                string style = $"session:{Base.GetHashCode()}";
                /*
                if (string.IsNullOrEmpty(_antennaList) == false)
                    style += ",antenna:" + _antennaList;
                    */

                var readerNameList = _readerNameList;
                if (string.IsNullOrEmpty(readerNameList) == false)
                {

                    var result = channel?.Object?.ListTags(readerNameList, style);
                    if (result.Value == -1)
                        Base.TriggerSetError(result,
                            new SetErrorEventArgs { Error = result.ErrorInfo });
                    else
                        Base.TriggerSetError(result,
                            new SetErrorEventArgs { Error = null }); // 清除以前的报错

                    lock (_syncRoot)
                    {
                        if (ListTags != null)
                        {
                            // 先记忆
                            _lastTags = result.Results;

                            // 注意 result.Value == -1 时也会触发这个事件
                            ListTags(channel, new ListTagsEventArgs
                            {
                                ReaderNameList = readerNameList,
                                Result = result
                            });
                        }
                        else
                            _lastTags = null;
                    }

                }

                // 检查门状态
                if (LockCommands != null)
                {
                    List<GetLockStateResult> errors = new List<GetLockStateResult>();
                    List<LockState> states = new List<LockState>();
                    {
                        // parameters:
                        //      lockNameParam   为 "锁控板名字.卡编号.锁编号"。
                        //                      其中卡编号部分可以是 "1" 也可以是 "1|2" 这样的形态
                        //                      其中锁编号部分可以是 "1" 也可以是 "1|2|3|4" 这样的形态
                        //                      如果缺乏卡编号和锁编号部分，缺乏的部分默认为 "1"
                        var lock_result = channel?.Object?.GetShelfLockState(LockCommands);
                        if (lock_result.Value == -1)
                            Base.TriggerSetError(lock_result,
                                new SetErrorEventArgs { Error = lock_result.ErrorInfo });
                        else
                            Base.TriggerSetError(lock_result,
                                new SetErrorEventArgs { Error = null }); // 清除以前的报错
                        if (lock_result.Value == -1)
                        {
                            // 注意 lock_result.Value == -1 时也会触发这个事件
                            ListLocks?.Invoke(channel, new ListLocksEventArgs
                            {
                                Result = lock_result
                            });
                        }
                        if (lock_result.States != null)
                            states.AddRange(lock_result.States);
                    }

                    if (states.Count > 0)
                    {
                        // 注意 lock_result.Value == -1 时也会触发这个事件
                        ListLocks?.Invoke(channel, new ListLocksEventArgs
                        {
                            Result = new GetLockStateResult { States = states }
                        });
                    }
                    // 门锁状态就绪
                    _lockReady = true;
                }
            },
            token);
        }


		~~~
		        // 增加了无标签时延迟等待功能。敏捷响应
        public ListTagsResult ListTags(string reader_name, string style)
        {
            if (Program.Rfid.Pause)
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = "RFID 功能处于暂停状态",
                    ErrorCode = "paused"
                };

            string lockNameList = StringUtil.GetParameterByPrefix(style, "getLockState");
            if (lockNameList != null)
                lockNameList = StringUtil.UnescapeString(lockNameList);

            Program.Rfid.IncApiCount();
            try
            {
                if (Program.Rfid.Pause)
                    return new ListTagsResult
                    {
                        Value = -1,
                        ErrorInfo = "RFID 功能处于暂停状态",
                        ErrorCode = "paused"
                    };

                string session_id = StringUtil.GetParameterByPrefix(style, "session");

                TimeSpan length = TimeSpan.FromSeconds(2);

                ListTagsResult result = null;
                GetLockStateResult lock_result = null;

                string current_uids = "";
                DateTime start = DateTime.Now;
                while (DateTime.Now - start < length
                    || result == null)
                {
                    if (string.IsNullOrEmpty(reader_name) == false)
                    {
                        result = _listTags(reader_name, style);

                        if (result != null && result.Results != null)
                            current_uids = BuildUids(result.Results);
                        else
                            current_uids = "";

                        // TODO: 这里的比较应该按照 Session 来进行
                        // 只要本次和上次 tag 数不同，立刻就返回
                        if (CompareLastUids(session_id, current_uids))
                        {
                            SetLastUids(session_id, current_uids);
                            return result;
                        }

                        if (result.Value == -1)
                        {
                            return result;
                        }
                    }
                    else
                        result = new ListTagsResult();

                    // 检测一下门锁状态是否有变化
                    // 目前是 1:1 次数分配
                    if (lockNameList != null)
                    {
                        lock_result = GetShelfLockState(lockNameList);
                        // 这里的疑问是，如果 _listTags 没有出错，是否应该坚持返回正确结果？
                        if (lock_result.Value != -1)
                        {
                            string current_states = BuildStateString(lock_result.States);
                            if (CompareLastUids(session_id + "_lock", current_states))
                            {
                                SetLastUids(session_id + "_lock", current_states);
                                return new ListTagsResult { GetLockStateResult = lock_result };
                            }
                        }
                    }

                    /*
                    // TODO: 如果本次和上次都是 2，是否立即返回？可否先对比一下 uid，有差别再返回?
                    if (result.Results != null
                        && result.Results.Count > 0)
                    {
                        SetLastUids(current_uids);
                        return result;
                    }
                    */
                    Thread.Sleep(10);  // 10? 200?
                }

                SetLastUids(session_id, current_uids);
                if (lockNameList != null && lock_result != null)
                    result.GetLockStateResult = lock_result;
                return result;
            }
            catch (Exception ex)
            {
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = $"ListTags() 出现异常:{ex.Message}"
                };
            }
            finally
            {
                Program.Rfid.DecApiCount();
            }
        }


		~~~
		第二个版本。先判断 inventory

		        // 增加了无标签时延迟等待功能。敏捷响应
        public ListTagsResult ListTags(string reader_name, string style)
        {
            if (Program.Rfid.Pause)
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = "RFID 功能处于暂停状态",
                    ErrorCode = "paused"
                };

            string lockNameList = StringUtil.GetParameterByPrefix(style, "getLockState");
            if (lockNameList != null)
                lockNameList = StringUtil.UnescapeString(lockNameList);

            Program.Rfid.IncApiCount();
            try
            {
                if (Program.Rfid.Pause)
                    return new ListTagsResult
                    {
                        Value = -1,
                        ErrorInfo = "RFID 功能处于暂停状态",
                        ErrorCode = "paused"
                    };

                string session_id = StringUtil.GetParameterByPrefix(style, "session");

                TimeSpan length = TimeSpan.FromSeconds(2);

                ListTagsResult result = null;
                GetLockStateResult lock_result = null;

                string current_uids = "";
                DateTime start = DateTime.Now;
                while (DateTime.Now - start < length
                    || result == null)
                {
                    // 执行 inventory
                    if (string.IsNullOrEmpty(reader_name) == false)
                    {
                        result = _listTags(reader_name, style);
                    }
                    else
                        result = new ListTagsResult();

                    // 判断 inventory 结果
                    if (string.IsNullOrEmpty(reader_name) == false)
                    {
                        if (result != null && result.Results != null)
                            current_uids = BuildUids(result.Results);
                        else
                            current_uids = "";

                        // TODO: 这里的比较应该按照 Session 来进行
                        // 只要本次和上次 tag 数不同，立刻就返回
                        if (CompareLastUids(session_id, current_uids))
                        {
                            SetLastUids(session_id, current_uids);
                            return result;
                        }

                        if (result.Value == -1)
                        {
                            return result;
                        }
                    }

                    // 执行门锁状态获取
                    // 目前是 1:1 次数分配
                    if (lockNameList != null)
                    {
                        lock_result = GetShelfLockState(lockNameList);
                        // 从此开始 result.GetLockStateResult 就有值了
                        result.GetLockStateResult = lock_result;
                    }

                    // 判断门锁状态
                    if (lockNameList != null)
                    {
                        // 这里的疑问是，如果 _listTags 没有出错，是否应该坚持返回正确结果？
                        if (lock_result.Value != -1)
                        {
                            string current_states = BuildStateString(lock_result.States);
                            if (CompareLastUids(session_id + "_lock", current_states))
                            {
                                SetLastUids(session_id + "_lock", current_states);
                                return result;
                            }
                        }
                    }

                    /*
                    // TODO: 如果本次和上次都是 2，是否立即返回？可否先对比一下 uid，有差别再返回?
                    if (result.Results != null
                        && result.Results.Count > 0)
                    {
                        SetLastUids(current_uids);
                        return result;
                    }
                    */
                    Thread.Sleep(10);  // 10? 200?
                }

                SetLastUids(session_id, current_uids);
                return result;
            }
            catch (Exception ex)
            {
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = $"ListTags() 出现异常:{ex.Message}"
                };
            }
            finally
            {
                Program.Rfid.DecApiCount();
            }
        }


		~~~

		        private void _barcodeCapture_BarCodeEvent(BarcodeCapture.KeyInput input)
        {
            if (_pauseBarcodeScan > 0)
            {
                Debug.WriteLine("pauseBarcodeScan");
                return;
            }

            Debug.WriteLine($"input.Barcode='{input.Barcode}'");

            if (input.Chr == '\0')
            {
                Debug.WriteLine("zero");
                return;
            }

            // this.AddErrors("input", new List<string> { $"your input:{barCode.Ascll}" });
            if (input.Chr == '\n' || input.Chr == '\r')
            {
                string line = _line.ToString();
                Debug.WriteLine($"line feed. line='{line}'");
                if (string.IsNullOrEmpty(line) == false)
                {
                    // 触发一次输入
                    LineFeed?.Invoke(this, new LineFeedEventArgs { Text = line });
                }
                _line.Clear();
                return;
            }

            // Debug.WriteLine($"chr={barCode.Chr}");
            // 防止内容太多
            if (_line.Length > 1000)
                _line.Clear();
            _line.Append(input.Chr);


            Debug.WriteLine($"append char '{(int)input.Chr}'");
        }


                // 首次初始化智能书柜所需的标签相关数据结构
        // 初始化开始前，要先把 RfidManager.ReaderNameList 设置为 "*"
        // 初始化完成前，先不要允许(开关门变化导致)修改 RfidManager.ReaderNameList
        public static async Task<InitialShelfResult> newVersion_InitialShelfEntities(
            Delegate_displayText func_display,
            Delegate_cancelled func_cancelled)
        {
            // TODO: 出现“正在初始化”的对话框。另外需要注意如果 DataReady 信号永远来不了怎么办
            WpfClientInfo.WriteInfoLog("开始初始化图书信息");
            func_display("开始初始化图书信息 ...");

            // 一个一个门地填充图书信息
            int i = 0;
            foreach (var door in Doors)
            {
                if (func_cancelled() == true)
                    return new InitialShelfResult();

                // 获得和一个门相关的 readernamelist
                var list = GetReaderNameList(new List<DoorItem> { door }, null);
                string style = $"dont_delay";   // 确保 inventory 并立即返回

                func_display($"{i + 1}/{Doors.Count} 门 {door.Name} ({list}) ...");

                var result = RfidManager.CallListTags(list, style);
                RfidManager.TriggerListTagsEvent(list, result, true);

                i++;
            }

            if (func_cancelled() == true)
                return new InitialShelfResult();

            WpfClientInfo.WriteInfoLog("开始填充图书队列");
            func_display("正在填充图书队列 ...");

            List<string> warnings = new List<string>();

            lock (_syncRoot_all)
            {
                _all.Clear();

                var books = TagList.Books;
                WpfClientInfo.WriteErrorLog($"books count={books.Count}, ReaderNameList={RfidManager.ReaderNameList}(注：此时门应该都是关闭的，图书读卡器应该是停止盘点状态)");
                foreach (var tag in books)
                {
                    if (func_cancelled() == true)
                        return new InitialShelfResult();

                    WpfClientInfo.WriteErrorLog($" tag={tag.ToString()}");

                    // 2019/12/17
                    // 判断一下 tag 是否属于已经定义的门范围
                    var doors = DoorItem.FindDoors(ShelfData.Doors, tag.OneTag.ReaderName, tag.OneTag.AntennaID.ToString());
                    if (doors.Count == 0)
                    {
                        WpfClientInfo.WriteInfoLog($"tag (UID={tag.OneTag?.UID}) 不属于任何已经定义的门，没有被加入 _all 集合。\r\ntag 详情：{tag.ToString()}");
                        continue;
                    }

                    try
                    {
                        // Exception:
                        //      可能会抛出异常 ArgumentException TagDataException
                        var entity = NewEntity(tag);

                        func_display($"正在填充图书队列 ({entity.PII})...");

                        _all.Add(entity);
                    }
                    catch (TagDataException ex)
                    {
                        warnings.Add($"UID 为 '{tag.OneTag?.UID}' 的标签出现数据格式错误: {ex.Message}");
                        WpfClientInfo.WriteErrorLog($"InitialShelfEntities() 遇到 tag (UID={tag.OneTag?.UID}) 数据格式出错：{ex.Message}\r\ntag 详情：{tag.ToString()}");
                    }
                }

            }

            /*
            {
                WpfClientInfo.WriteInfoLog("等待锁控就绪");
                func_display("等待锁控就绪 ...");
                // 恢复 Base2 线程运行
                // RfidManager.Pause2 = false;
                bool ret = await Task.Run(() =>
                {
                    while (true)
                    {
                        if (OpeningDoorCount != -1)
                            return true;
                        if (func_cancelled() == true)
                            return false;
                        Thread.Sleep(100);
                    }
                });

                if (ret == false)
                    return new InitialShelfResult();
            }
            */

            // DoorItem.DisplayCount(_all, _adds, _removes, App.CurrentApp.Doors);
            RefreshCount();

            // TryReturn(progress, _all);
            _firstInitial = true;   // 第一次初始化已经完成

            func_display("获取图书册记录信息 ...");

            var task = Task.Run(async () =>
            {
                CancellationToken token = CancelToken;
                await FillBookFields(All, token);
                await FillBookFields(Adds, token);
                await FillBookFields(Removes, token);
            });

            return new InitialShelfResult { Warnings = warnings };
        }


        #if OLD_VERSION
        // 初始化开始前，要先把 RfidManager.ReaderNameList 设置为 "*"
        // 初始化完成前，先不要允许(开关门变化导致)修改 RfidManager.ReaderNameList
        async Task InitialShelfEntities()
        {
            if (ShelfData.FirstInitialized)
                return;

            this.doorControl.Visibility = Visibility.Collapsed;
            _initialCancelled = false;

            ProgressWindow progress = null;
            Application.Current.Dispatcher.Invoke(new Action(() =>
            {
                progress = new ProgressWindow();
                progress.TitleText = "初始化智能书柜";
                progress.MessageText = "正在初始化图书信息，请稍候 ...";
                progress.Owner = Application.Current.MainWindow;
                progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                progress.Closed += Progress_Cancelled;
                App.SetSize(progress, "tall");
                // progress.Width = Math.Min(700, this.ActualWidth);
                // progress.Height = Math.Min(900, this.ActualHeight);
                progress.okButton.Content = "取消";
                progress.Show();
                AddLayer();
            }));
            this.doorControl.Visibility = Visibility.Hidden;

            try
            {
                var initial_result = await ShelfData.InitialShelfEntities(
                    (s) =>
                    {
                        DisplayMessage(progress, s, "green");
                    },
                    () =>
                    {
                        return _initialCancelled;
                    });

                if (_initialCancelled)
                    return;

                // 2019/11/29
                // 先报告一次标签数据错误
                if (initial_result.Warnings?.Count > 0)
                {
                    ErrorBox(StringUtil.MakePathList(initial_result.Warnings, "\r\n"));
                }

#if NO
                // TODO: 出现“正在初始化”的对话框。另外需要注意如果 DataReady 信号永远来不了怎么办
                await Task.Run(() =>
                {
                    TagList.DataReady = false;
                    // TODO: 是否一开始主动把 RfidManager ReaderNameList 设置为 "*"?
                    while (true)
                    {
                        if (TagList.DataReady == true)
                            return true;
                        Thread.Sleep(100);
                    }
                });

                _all.Clear();
                var books = TagList.Books;
                foreach (var tag in books)
                {
                    _all.Add(NewEntity(tag));
                }

                // DoorItem.DisplayCount(_all, _adds, _removes, App.CurrentApp.Doors);
                ShelfData.RefreshCount();
#endif
                // 把门显示出来。因为此时需要看到是否关门的状态
                this.doorControl.Visibility = Visibility.Visible;
                this.doorControl.InitializeButtons(ShelfData.ShelfCfgDom, ShelfData.Doors);

                // 检查门是否为关闭状态？
                // 注意 RfidManager 中门锁启动需要一定时间。状态可能是：尚未初始化/有门开着/门都关了
                await Task.Run(() =>
                {
                    while (ShelfData.OpeningDoorCount > 0)
                    {
                        if (_initialCancelled)
                            break;
                        DisplayMessage(progress, "请关闭全部柜门，以完成初始化", "yellow");
                        Thread.Sleep(1000);
                    }
                });

                if (_initialCancelled)
                    return;

                // 此时门是关闭状态。让读卡器切换到节省盘点状态
                ShelfData.RefreshReaderNameList();

                // TODO: 如何显示还书操作中的报错信息? 看了报错以后点继续?
                // result.Value
                //      -1  出错
                //      0   没有必要处理
                //      1   已经处理
                var result = TryReturn(progress, ShelfData.All);
                if (result.MessageDocument != null
                    && result.MessageDocument.ErrorCount > 0)
                {
                    string speak = "";
                    {
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            progress.BackColor = "yellow";
                            progress.MessageDocument = result.MessageDocument.BuildDocument(18, out speak);
                            if (result.MessageDocument.ErrorCount > 0)
                                progress = null;
                        }));
                    }
                    if (string.IsNullOrEmpty(speak) == false)
                        App.CurrentApp.Speak(speak);
                }

                if (_initialCancelled)
                    return;

                /*
                if (_initialCancelled == false)
                {
                    this.doorControl.Visibility = Visibility.Visible;
                }
                */

                /*
                var manage_result = RfidManager.ManageReader(ShelfData.DoorReaderName, "CloseRFTransmitter");
                if (manage_result.Value == -1)
                    this.SetGlobalError("InitialShelfEntities", $"ManageReader() 出错: {manage_result.ErrorInfo}");
                    */
                SelectAntenna();
            }
            finally
            {
                // _firstInitial = true;   // 第一次初始化已经完成
                RemoveLayer();

                if (_initialCancelled == false)
                {
                    // PageMenu.MenuPage.shelf.Visibility = Visibility.Visible;

                    if (progress != null)
                    {
                        progress.Closed -= Progress_Cancelled;
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            if (progress != null)
                                progress.Close();
                        }));
                    }

                    SetGlobalError("initial", null);
                    this.Mode = ""; // 从初始化模式转为普通模式
                }
                else
                {
                    ShelfData.FirstInitialized = false;

                    // PageMenu.MenuPage.shelf.Visibility = Visibility.Collapsed;

                    // TODO: 页面中央大字显示“书柜初始化失败”。重新进入页面时候应该自动重试初始化
                    SetGlobalError("initial", "智能书柜初始化失败。请检查读卡器和门锁参数配置，重新进行初始化 ...");
                    /*
                    ProgressWindow error = null;
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        error = new ProgressWindow();
                        error.Owner = Application.Current.MainWindow;
                        error.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                        error.Closed += Error_Closed;
                        error.Show();
                        AddLayer();
                    }));
                    DisplayError(ref error, "智能书柜初始化失败。请检查读卡器和门锁参数配置，重新进行初始化 ...");
                    */
                }
            }

            // TODO: 初始化中断后，是否允许切换到菜单和设置画面？(只是不让进入书架画面)
        }

#else
#endif


~~~~~~~~
        // 新版本的首次填充图书信息的函数
        async Task InitialShelfEntities()
        {
            if (ShelfData.FirstInitialized)
                return;

            // 尚未配置 shelf.xml
            if (ShelfData.ShelfCfgDom == null)
                return;

            Application.Current.Dispatcher.Invoke(new Action(() =>
            {
                this.doorControl.Visibility = Visibility.Collapsed;
            }));

            _initialCancelled = false;

            ProgressWindow progress = null;
            Application.Current.Dispatcher.Invoke(new Action(() =>
            {
                progress = new ProgressWindow();
                progress.TitleText = "初始化智能书柜";
                progress.MessageText = "正在初始化图书信息，请稍候 ...";
                progress.Owner = Application.Current.MainWindow;
                progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                progress.Closed += Progress_Cancelled;
                App.SetSize(progress, "tall");
                // progress.Width = Math.Min(700, this.ActualWidth);
                // progress.Height = Math.Min(900, this.ActualHeight);
                progress.okButton.Content = "取消";
                progress.Show();
                AddLayer();
            }));

            Application.Current.Dispatcher.Invoke(new Action(() =>
            {
                // 把门显示出来。因为此时需要看到是否关门的状态
                this.doorControl.Visibility = Visibility.Visible;
                this.doorControl.InitializeButtons(ShelfData.ShelfCfgDom, ShelfData.Doors);
            }));

            // 等待锁控就绪
            var lock_result = await ShelfData.WaitLockReady(
                (s) =>
                {
                    DisplayMessage(progress, s, "green");
                },
                () =>
                {
                    return _initialCancelled;
                })
                .ConfigureAwait(false);
            if (lock_result.Value == -1)
                return;

            try
            {

                // 检查门是否为关闭状态？
                // 注意 RfidManager 中门锁启动需要一定时间。状态可能是：尚未初始化/有门开着/门都关了
                await Task.Run(() =>
                {
                    while (ShelfData.OpeningDoorCount > 0)
                    {
                        if (_initialCancelled)
                            break;
                        DisplayMessage(progress, "请关闭全部柜门，以完成初始化", "yellow");
                        Thread.Sleep(1000);
                    }
                });

                if (_initialCancelled)
                    return;

                // 此时门是关闭状态。让读卡器切换到节省盘点状态
                ShelfData.RefreshReaderNameList();

                // TODO: 填充 RFID 图书标签信息
                var initial_result = await ShelfData.newVersion_InitialShelfEntities(
    (s) =>
    {
        DisplayMessage(progress, s, "green");
        // Thread.Sleep(1000);
    },
    () =>
    {
        return _initialCancelled;
    }).ConfigureAwait(false);

                if (_initialCancelled)
                    return;

                // 2019/11/29
                // 先报告一次标签数据错误
                if (initial_result.Warnings?.Count > 0)
                {
                    ErrorBox(StringUtil.MakePathList(initial_result.Warnings, "\r\n"));
                }

                DisplayMessage(progress, "自动盘点图书 ...", "green");

                WpfClientInfo.WriteInfoLog("自动盘点全部图书开始");

                // TODO: 如何显示还书操作中的报错信息? 看了报错以后点继续?
                // result.Value
                //      -1  出错
                //      0   没有必要处理
                //      1   已经处理
                var result = await InventoryBooks(progress, ShelfData.All);
                WpfClientInfo.WriteInfoLog("自动盘点全部图书结束");

                if (result.MessageDocument != null
                    && result.MessageDocument.ErrorCount > 0)
                {
                    string speak = "";
                    {
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            progress.BackColor = "yellow";
                            progress.MessageDocument = result.MessageDocument.BuildDocument(18, out speak);
                            if (result.MessageDocument.ErrorCount > 0)
                                progress = null;
                        }));
                    }
                    if (string.IsNullOrEmpty(speak) == false)
                        App.CurrentApp.Speak(speak);

                    _initialCancelled = true;   // 表示初始化失败
                }

                if (_initialCancelled)
                    return;

                SelectAntenna();

                // 将 RetryActions 里面的 PII 和 ShelfData.All 里面 PII 相同的事项删除。因为刚才 TryReturn() 已经成功提交了它们
                ShelfData.RemoveFromRetryActions(new List<Entity>(ShelfData.All));

                // 启动重试任务。此任务长期在后台运行
                ShelfData.StartRequestTask();
            }
            finally
            {
                // _firstInitial = true;   // 第一次初始化已经完成
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    RemoveLayer();
                }));

                if (_initialCancelled == false)
                {
                    // PageMenu.MenuPage.shelf.Visibility = Visibility.Visible;

                    if (progress != null)
                    {
                        progress.Closed -= Progress_Cancelled;
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            if (progress != null)
                                progress.Close();
                        }));
                    }

                    SetGlobalError("initial", null);
                    this.Mode = ""; // 从初始化模式转为普通模式
                }
                else
                {
                    ShelfData.FirstInitialized = false;

                    // PageMenu.MenuPage.shelf.Visibility = Visibility.Collapsed;

                    // TODO: 页面中央大字显示“书柜初始化失败”。重新进入页面时候应该自动重试初始化
                    SetGlobalError("initial", "智能书柜初始化失败。请检查读卡器和门锁参数配置，重新进行初始化 ...");
                    /*
                    ProgressWindow error = null;
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        error = new ProgressWindow();
                        error.Owner = Application.Current.MainWindow;
                        error.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                        error.Closed += Error_Closed;
                        error.Show();
                        AddLayer();
                    }));
                    DisplayError(ref error, "智能书柜初始化失败。请检查读卡器和门锁参数配置，重新进行初始化 ...");
                    */
                }
            }

            // TODO: 初始化中断后，是否允许切换到菜单和设置画面？(只是不让进入书架画面)
        }


        ~~~~~~~~~~~~~

                // 新版本的事件
#pragma warning disable VSTHRD100 // 避免使用 Async Void 方法
        private async void CurrentApp_NewTagChanged(object sender, NewTagChangedEventArgs e)
#pragma warning restore VSTHRD100 // 避免使用 Async Void 方法
        {
            // TODO: 对已经拿走的读者卡，用 TagList.ClearTagTable() 清除它的缓存内容

            // 读者。不再精细的进行增删改跟踪操作，而是笼统地看 TagList.Patrons 集合即可
            /*
            _ = Task.Run(async () =>
            {
                var result = await ShelfData.ChangePatronTagsAsync((BaseChannel<IRfid>)sender,
                    e);
                if (result.Value > 0)
                    await RefreshPatronsAsync();
            });
            */

            {
                var result = await ShelfData.ChangePatronTagsAsync((BaseChannel<IRfid>)sender,
    e);
                if (result.Value > 0)
                    await RefreshPatronsAsync();
            }

            await ShelfData.ChangeEntitiesAsync((BaseChannel<IRfid>)sender,
                e,
                () =>
                {
                    // 如果图书数量有变动，要自动清除挡在前面的残留的对话框
                    CloseDialogs();
                });

            // "initial" 模式下，立即合并到 _all。等关门时候一并提交请求
            // TODO: 不过似乎此时有语音提示放入、取出，似乎更显得实用一些？
            if (this.Mode == "initial")
            {
                var adds = ShelfData.Adds; // new List<Entity>(ShelfData.Adds);
                {
                    ShelfData.Add("all", adds);

                    ShelfData.Remove("adds", adds);
                    ShelfData.Remove("removes", adds);
                }

                var removes = ShelfData.Removes;
                {
                    ShelfData.Remove("all", removes);

                    ShelfData.Remove("adds", removes);
                    ShelfData.Remove("removes", removes);
                }

                ShelfData.RefreshCount();
            }
        }


        ~~~~~~~~~~


                // 新版本事件
        // 跟随事件动态更新列表
        // Add: 检查列表中是否存在这个 PII，如果存在，则修改状态为 在架，并设置 UID 成员
        //      如果不存在，则为列表添加一个新元素，修改状态为在架，并设置 UID 和 PII 成员
        // Remove: 检查列表中是否存在这个 PII，如果存在，则修改状态为 不在架
        //      如果不存在这个 PII，则不做任何动作
        // Update: 检查列表中是否存在这个 PII，如果存在，则修改状态为 在架，并设置 UID 成员
        //      如果不存在，则为列表添加一个新元素，修改状态为在架，并设置 UID 和 PII 成员
        public static async Task ChangeEntitiesAsync(BaseChannel<IRfid> channel,
            NewTagChangedEventArgs e,
            Delagate_booksChanged func_booksChanged)
        {
            if (ShelfData.FirstInitialized == false)
                return;

            // 开门状态下，动态信息暂时不要合并
            bool changed = false;

            List<TagAndData> tags = new List<TagAndData>();
            if (e.AddTags != null)
            {
                tags.AddRange(e.AddTags);
                /*
                // 延时触发 SelectAntenna()
                if (e.AddTags.Count > 0)
                    _tagAdded = true;
                    */
            }

            if (e.UpdateTags != null)
            {
                tags.AddRange(e.UpdateTags);
                /*
                // 2020/4/15
                if (e.UpdateTags.Count > 0)
                    _tagAdded = true;
                    */
            }

            // 2020/4/11
            // 忽略读者读卡器上的标签
            {
                var filtered = tags.FindAll(tag =>
                {
                    //if (tag.OneTag.Protocol != InventoryInfo.ISO15693)
                    //    return false;
                    // 加快判断速度，先排除读者读卡器上的标签
                    if (tag.OneTag.ReaderName == _patronReaderName)
                        return false;

                    if (tag.OneTag.Protocol == InventoryInfo.ISO15693
                        && tag.OneTag.TagInfo == null)
                        return false;   // 忽略还没有 TagInfo 的那些超前的通知

                    // 判断一下 tag 是否属于已经定义的门范围
                    var doors = DoorItem.FindDoors(ShelfData.Doors, tag.OneTag.ReaderName, tag.OneTag.AntennaID.ToString());
                    if (doors.Count > 0)
                        return true;
                    return false;
                });

                tags = filtered;
            }

            // 延时触发 SelectAntenna()
            if (tags.Count > 0)
            {
                _ = Task.Run(async () =>
                {
                    // 延时设置
                    await Task.Delay(TimeSpan.FromSeconds(10), App.CancelToken);
                    _tagAdded = true;
                });
            }

            List<string> add_uids = new List<string>();
            int removeBooksCount = 0;
            lock (_syncRoot_all)
            {
                // 新添加标签(或者更新标签信息)
                foreach (var tag in tags)
                {
                    // 没有 TagInfo 信息的先跳过
                    if (tag.OneTag.TagInfo == null)
                        continue;

                    add_uids.Add(tag.OneTag.UID);

                    // 看看 _all 里面有没有
                    var results = Find(_all, tag);
                    if (results.Count == 0)
                    {
                        // Exception:
                        //      可能会抛出异常 ArgumentException TagDataException
                        if (Add(_adds, tag) == true)
                        {
                            changed = true;

                            // 刚刚增加的 patron 的 UID，记忆下来
                            //if (tag.Type == "patron")
                            //    new_patron_uids.Add(tag.OneTag.UID);
                        }
                        if (Remove(_removes, tag) == true)
                            changed = true;
                    }
                    else
                    {
                        // 更新 _all 里面的信息
                        if (Update(_all, tag) == true)
                        {
                            // Exception:
                            //      可能会抛出异常 ArgumentException TagDataException
                            Add(_changes, tag);
                        }

                        // 要把 _adds 和 _removes 里面都去掉
                        if (Remove(_adds, tag) == true)
                            changed = true;
                        if (Remove(_removes, tag) == true)
                            changed = true;
                    }
                }

                List<TagAndData> removes = null;
                {
                    // 2020/4/9
                    // 把书柜读卡器上的(ISO15693)读者卡也计算在内
                    removes = e.RemoveTags?.FindAll(tag =>
                    {
                        //if (tag.OneTag.Protocol != InventoryInfo.ISO15693)
                        //    return false;

                        // 加快判断速度，先排除读者读卡器上的标签
                        if (tag.OneTag.ReaderName == _patronReaderName)
                            return false;

                        // 判断一下 tag 是否属于已经定义的门范围
                        var doors = DoorItem.FindDoors(ShelfData.Doors, tag.OneTag.ReaderName, tag.OneTag.AntennaID.ToString());
                        if (doors.Count > 0)
                            return true;
                        return false;
                    });
                }

                // 拿走标签
                foreach (var tag in removes)
                {
                    if (tag.OneTag.TagInfo == null)
                        continue;

                    // 刚添加过的标签，这里就不要去移走了。即，添加比移除要优先
                    if (add_uids.IndexOf(tag.OneTag.UID) != -1)
                        continue;

                    // 看看 _all 里面有没有
                    var results = Find("all", tag);
                    if (results.Count > 0)
                    {
                        if (Remove(_adds, tag) == true)
                            changed = true;
                        if (Remove(_changes, tag) == true)
                            changed = true;
                        /*
                        if (Add(_removes, tag) == true)
                        {
                            changed = true;
                        }
                        */
                        // 2020/4/5
                        // 这样可以利用 All 里面的 Entity 对象，通常其 Title 属性已经有值
                        if (Add("removes", results[0]) == true)
                            changed = true;
                    }
                    else
                    {
                        // _all 里面没有，很奇怪(是否写入错误日志？)。但，
                        // 要把 _adds 和 _removes 里面都去掉
                        if (Remove(_adds, tag) == true)
                            changed = true;
                        if (Remove(_removes, tag) == true)
                            changed = true;
                        if (Remove(_changes, tag) == true)
                            changed = true;
                    }

                    removeBooksCount++;
                }
            }

            /*
            StringUtil.RemoveDup(ref add_uids, false);
            int add_count = add_uids.Count;
            int remove_count = 0;
            if (e.RemoveTags != null)
                remove_count = removeBooksCount; // 注： e.RemoveBooks.Count 是不准确的，有时候会把 ISO15693 的读者卡判断时作为 remove 信号

            */

            // TODO: 把 add remove error 动作分散到每个门，然后再触发 ShelfData.BookChanged 事件

            if (changed == true)
            {
                // DoorItem.DisplayCount(_all, _adds, _removes, ShelfData.Doors);
                ShelfData.RefreshCount();
                func_booksChanged?.Invoke();
            }

            // TODO: 平时可以建立一个 cache，以后先从 cache 里面取书目摘要字符串
            var task = Task.Run(async () =>
            {
                CancellationToken token = CancelToken;
                await FillBookFieldsAsync(All, token, "refreshCount");
                await FillBookFieldsAsync(Adds, token, "refreshCount");
                await FillBookFieldsAsync(Removes, token, "refreshCount");
            });
        }


        ~~~~~~~~

                // SetBorrowed("") 可以清除列表
        public void SetBorrowed(string patron_xml)
        {
            _borrowedEntities.Clear();

            if (string.IsNullOrEmpty(patron_xml) == false)
            {
                XmlDocument dom = new XmlDocument();
                dom.LoadXml(patron_xml);

                // 用 hashtable 保存一下每个 entity 的原始序
                Hashtable originIndexTable = new Hashtable();
                int i = 0;

                List<Entity> entities = new List<Entity>();
                XmlNodeList borrows = dom.DocumentElement.SelectNodes("borrows/borrow");
                foreach (XmlElement borrow in borrows)
                {
                    string barcode = borrow.GetAttribute("barcode");
                    var new_entity = new Entity { PII = barcode, Container = _borrowedEntities };
                    entities.Add(new_entity);
                    originIndexTable[new_entity] = i++;
                }

                entities.Sort((a, b) =>
                {
                    return CompareEntities(a, b, originIndexTable);
                });

                foreach (var entity in entities)
                {
                    _borrowedEntities.Add(entity);
                }
            }
        }

        static bool IsState(Entity entity, string sub)
        {
            return StringUtil.IsInList(sub, entity.State);
        }

        // 对 Entity 进行排序
        // TODO: 余下的建议按照应还日期，日期靠前排序。这样便于读者观察到需要尽快还书的册
        static int CompareEntities(Entity a, 
            Entity b,
            Hashtable originIndexTable)
        {
            int index_a = (int)originIndexTable[a];
            int index_b = (int)originIndexTable[b];
            bool a_overflow = IsState(a, "overflow");
            bool b_overflow = IsState(b, "overflow");
            if (a_overflow && b_overflow)
                return index_a - index_b;

            if (a_overflow)
                return -1;
            if (b_overflow)
                return 1;

            // 按原来的序
            return index_a - index_b;
        }


        ~~~~~~~~~~~

                // 获得一个册的题名字符串
        // .Value
        //      0   没有找到
        //      1   找到
        public static async Task<GetEntityDataResult> GetEntityDataAsync(string pii)
        {
            using (var releaser = await _channelLimit.EnterAsync())
            {
                LibraryChannel channel = App.CurrentApp.GetChannel();
                TimeSpan old_timeout = channel.Timeout;
                channel.Timeout = TimeSpan.FromSeconds(10);
                try
                {
                    // TODO: ItemXml 和 BiblioSummary 可以考虑在本地缓存一段时间
                    int nRedoCount = 0;
                REDO_GETITEMINFO:
                    long lRet = channel.GetItemInfo(null,
                        "item",
                        pii,
                        "",
                        "xml",
                        out string item_xml,
                        out string item_recpath,
                        out _,
                        "",
                        out _,
                        out _,
                        out string strError);
                    if (lRet == -1)
                    {
                        if ((channel.ErrorCode == ErrorCode.RequestError ||
                            channel.ErrorCode == ErrorCode.RequestTimeOut)
                            && nRedoCount < 2)
                        {
                            nRedoCount++;
                            goto REDO_GETITEMINFO;
                        }
                        return new GetEntityDataResult
                        {
                            Value = -1,
                            ErrorInfo = strError,
                            ErrorCode = channel.ErrorCode.ToString()
                        };
                    }

                    // 先尝试从本地书目库中获取书目摘要
                    using (BiblioCacheContext context = new BiblioCacheContext())
                    {
                        if (_cacheDbCreated == false)
                        {
                            context.Database.EnsureCreated();
                            _cacheDbCreated = true;
                        }
                        var item = context.BiblioSummaries.Where(o => o.PII == pii).FirstOrDefault();
                        if (item != null)
                            return new GetEntityDataResult
                            {
                                Value = 1,
                                ItemXml = item_xml,
                                ItemRecPath = item_recpath,
                                Title = item.BiblioSummary,
                            };
                    }

                    nRedoCount = 0;
                REDO_GETBIBLIOSUMMARY:
                    lRet = channel.GetBiblioSummary(
        null,
        pii,
        "", // strConfirmItemRecPath,
        null,
        out _,
        out string strSummary,
        out strError);
                    if (lRet == -1)
                    {
                        if ((channel.ErrorCode == ErrorCode.RequestError ||
        channel.ErrorCode == ErrorCode.RequestTimeOut)
        && nRedoCount < 2)
                        {
                            nRedoCount++;
                            goto REDO_GETBIBLIOSUMMARY;
                        }
                        return new GetEntityDataResult
                        {
                            Value = -1,
                            ErrorInfo = strError,
                            ErrorCode = channel.ErrorCode.ToString(),
                        };
                    }

                    strSummary = strSummary?.Replace(". -- ", "\r\n");   // .Replace("/", "\r\n");

                    // 存入数据库备用
                    if (lRet == 1)
                    {
                        try
                        {
                            using (BiblioCacheContext context = new BiblioCacheContext())
                            {
                                context.BiblioSummaries.Add(new BiblioSummaryItem
                                {
                                    PII = pii,
                                    BiblioSummary = strSummary
                                });
                                await context.SaveChangesAsync();
                            }
                        }
                        catch
                        {

                        }
                    }

                    return new GetEntityDataResult
                    {
                        Value = (int)lRet,
                        ItemXml = item_xml,
                        ItemRecPath = item_recpath,
                        Title = strSummary,
                        ErrorInfo = strError,
                        ErrorCode = channel.ErrorCode.ToString()
                    };
                }
                finally
                {
                    channel.Timeout = old_timeout;
                    App.CurrentApp.ReturnChannel(channel);
                }
            }
        }


        ~~~~~~~~~~~~~

                // TODO: 报错信息尝试用 FlowDocument 改造
        // 首次初始化时候对所有图书进行盘点操作。盘点的意思就是清点在书柜里面的图书
        // 注意观察和测试 PII 在 dp2library 中不存在的情况
        // 算法是对每一册图书尝试进行一次还书操作
        // result.Value
        //      -1  出错
        //      0   没有必要处理
        //      1   已经处理
        async Task<SubmitResult> InventoryBooksAsync(InventoryWindow progress,
            IReadOnlyCollection<Entity> entities)
        {
            DateTime now = DateTime.Now;

            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in entities)
            {
                actions.Add(new ActionInfo
                {
                    Entity = entity.Clone(),
                    Action = "return",
                    Operator = GetOperator(entity, false),
                    OperTime = now,
                });
                actions.Add(new ActionInfo
                {
                    Entity = entity.Clone(),
                    Action = "transfer",
                    CurrentShelfNo = ShelfData.GetShelfNo(entity),
                    Operator = GetOperator(entity, false),
                    OperTime = now,
                });

                // 2020/4/2
                // 还书操作前先尝试修改 EAS
                {
                    var eas_result = ShelfData.SetEAS(entity.UID, entity.Antenna, false);
                    if (eas_result.Value == -1)
                    {
                        return new SubmitResult
                        {
                            Value = -1,
                            ErrorInfo = $"修改册 '{entity.PII}' 的 EAS 失败: {eas_result.ErrorInfo}",
                            ErrorCode = "setEasError"
                        };
                    }
                }
            }

            if (actions.Count == 0)
                return new SubmitResult();  // 没有必要处理

            // 初始化的操作也要写入本地操作日志
            // await ShelfData.SaveActionsToDatabase(actions);

            // 立即处理，然后在界面报错
            var result = await ShelfData.SubmitCheckInOutAsync(
                (min, max, value, text) =>
                {
                    if (progress != null)
                    {
                        App.Invoke(new Action(() =>
                        {
                            if (min == -1 && max == -1 && value == -1)
                                progress.ProgressBar.Visibility = Visibility.Collapsed;
                            else
                                progress.ProgressBar.Visibility = Visibility.Visible;

                            //if (text != null)
                            //    progress.MessageText = text;

                            if (min != -1)
                                progress.ProgressBar.Minimum = min;
                            if (max != -1)
                                progress.ProgressBar.Maximum = max;
                            if (value != -1)
                                progress.ProgressBar.Value = value;
                        }));
                    }
                },
                //"", // _patron.Barcode,
                //"", // _patron.PatronName,
                actions,
                "");

            // TODO: 如果不是全部 actions 都成功，则要显示出有问题的图书(特别是所在的门名字)，
            // 等工作人员解决问题，重新盘点。直到全部成功。
            // 显示出错误信息后，要提供开门的按钮，方便工作人员打开门取放图书以便重试盘点

            return result;
        }