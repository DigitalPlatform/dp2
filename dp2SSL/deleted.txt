

        void SubmitCheckInOut(bool clearPatron = true, bool silence = false)
        {
            // TODO: 如果当前没有读者身份，则当作初始化处理，将书柜内的全部图书做还书尝试；被拿走的图书记入本地日志(所谓无主操作)
            // TODO: 注意还书，也就是往书柜里面放入图书，是不需要具体读者身份就可以提交的

            // TODO: 属于 free 类型的门里面的图书不要参与处理

            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in ShelfData.Adds)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo { Entity = entity, Action = "return" });
            }
            foreach (var entity in ShelfData.Removes)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo { Entity = entity, Action = "borrow" });
            }

            if (actions.Count == 0)
                return;

            ProgressWindow progress = null;
            string patron_name = "";
            patron_name = _patron.PatronName;

            if (silence == false)
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress = new ProgressWindow();
                    progress.MessageText = "正在处理，请稍候 ...";
                    progress.Owner = Application.Current.MainWindow;
                    progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    progress.Closed += Progress_Closed;
                    progress.Width = Math.Min(700, this.ActualWidth);
                    progress.Height = Math.Min(500, this.ActualHeight);
                    progress.Show();
                    AddLayer();
                }));
            }

            // 先尽量执行还书请求，再报错说无法进行借书操作(记入错误日志)
            MessageDocument doc = new MessageDocument();

            bool patron_filled = false;

            // 检查读者卡状态是否 OK
            if (IsPatronOK("open", out string check_message) == false)
            {
                /*
                if (string.IsNullOrEmpty(check_message))
                    check_message = $"读卡器上的当前读者卡状态不正确。无法进行 checkin/out 操作";

                DisplayError(ref progress, check_message);
                return;
                */
            }
            else
                patron_filled = true;

            LibraryChannel channel = App.CurrentApp.GetChannel();
            try
            {
                // ClearEntitiesError();

                if (progress != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.ProgressBar.Value = 0;
                        progress.ProgressBar.Minimum = 0;
                        progress.ProgressBar.Maximum = actions.Count;
                    }));
                }

                // TODO: 准备工作：把涉及到的 Entity 对象的字段填充完整
                // 检查 PII 是否都具备了

                int skip_count = 0;
                int success_count = 0;
                List<string> errors = new List<string>();
                List<string> borrows = new List<string>();
                List<string> returns = new List<string>();
                List<string> warnings = new List<string>();
                foreach (ActionInfo info in actions)
                {
                    string action = info.Action;
                    Entity entity = info.Entity;

                    string action_name = "借书";
                    if (action == "return")
                        action_name = "还书";
                    else if (action == "renew")
                        action_name = "续借";

                    // 借书操作必须要有读者卡。(还书和续借，可要可不要)
                    if (action == "borrow")
                    {
                        if (patron_filled == false)
                        {
                            // 界面警告
                            errors.Add($"册 '{entity.PII}' 无法进行借书请求");
                            // 写入错误日志
                            WpfClientInfo.WriteInfoLog($"册 '{entity.PII}' 无法进行借书请求");
                            continue;
                        }

                        if (string.IsNullOrEmpty(_patron.Barcode))
                        {
                            DisplayError(ref progress, $"请先在读卡器上放好读者卡，再进行{action_name}");
                            return;
                        }
                    }

                    long lRet = 0;
                    string strError = "";
                    string[] item_records = null;
                    string[] biblio_records = null;
                    BorrowInfo borrow_info = null;

                    if (action == "borrow" || action == "renew")
                    {
                        /*
                        if (action == "borrow" && entity.State == "borrowed")
                        {
                            entity.SetError($"本册是外借状态。{action_name}操作被忽略", "yellow");
                            skip_count++;
                            continue;
                        }
                        if (action == "renew" && entity.State == "onshelf")
                        {
                            entity.SetError($"本册是在馆状态。{action_name}操作被忽略 (只有处于外借状态的册才能进行续借)", "yellow");
                            skip_count++;
                            continue;
                        }
                        */
                        // TODO: 智能书柜要求强制借书。如果册操作前处在被其他读者借阅状态，要自动先还书再进行借书

                        entity.Waiting = true;
                        lRet = channel.Borrow(null,
                            action == "renew",
                            _patron.Barcode,
                            entity.PII,
                            entity.ItemRecPath,
                            false,
                            null,
                            "item,reader,biblio,overflowable", // style,
                            "xml", // item_format_list
                            out item_records,
                            "xml",
                            out string[] reader_records,
                            "summary",
                            out biblio_records,
                            out string[] dup_path,
                            out string output_reader_barcode,
                            out borrow_info,
                            out strError);

                    }
                    else if (action == "return")
                    {
                        /*
                        if (entity.State == "onshelf")
                        {
                            entity.SetError($"本册是在馆状态。{action_name}操作被忽略", "yellow");
                            skip_count++;
                            continue;
                        }
                        */

                        /*
                        // TODO: 增加检查 EAS 现有状态功能，如果已经是 true 则不用修改，后面 API 遇到出错后也不要回滚 EAS
                        // return 操作，提前修改 EAS
                        // 注: 提前修改 EAS 的好处是比较安全。相比 API 执行完以后再修改 EAS，提前修改 EAS 成功后，无论后面发生什么，读者都无法拿着这本书走出门禁
                        {
                            var result = SetEAS(entity.UID, entity.Antenna, action == "return");
                            if (result.Value == -1)
                            {
                                entity.SetError($"{action_name}时修改 EAS 动作失败: {result.ErrorInfo}", "red");
                                errors.Add($"册 '{entity.PII}' {action_name}时修改 EAS 动作失败: {result.ErrorInfo}");
                                continue;
                            }
                        }
                        */
                        // 智能书柜不使用 EAS 状态。可以考虑统一修改为 EAS Off 状态？

                        entity.Waiting = true;
                        lRet = channel.Return(null,
                            "return",
                            "", // _patron.Barcode,
                            entity.PII,
                            entity.ItemRecPath,
                            false,
                            "item,reader,biblio", // style,
                            "xml", // item_format_list
                            out item_records,
                            "xml",
                            out string[] reader_records,
                            "summary",
                            out biblio_records,
                            out string[] dup_path,
                            out string output_reader_barcode,
                            out ReturnInfo return_info,
                            out strError);
                    }

                    if (progress != null)
                    {
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            progress.ProgressBar.Value++;
                        }));
                    }

                    if (biblio_records != null && biblio_records.Length > 0)
                        entity.Title = biblio_records[0];

                    string title = entity.PII;
                    if (string.IsNullOrEmpty(entity.Title) == false)
                        title += " (" + entity.Title + ")";

                    {
                        // 把 _adds 和 _removes 归入 _all
                        // 一边处理一边动态修改 _all?
                        if (action == "return")
                            ShelfData.Add(ShelfData.All, entity);
                        else
                            ShelfData.Remove(ShelfData.All, entity);

                        ShelfData.Remove(ShelfData.Adds, entity);
                        ShelfData.Remove(ShelfData.Removes, entity);
                    }

                    string resultType = "succeed";
                    if (lRet == -1)
                        resultType = "error";
                    else if (lRet == 1)
                        resultType = "information";
                    MessageItem messageItem = new MessageItem
                    {
                        Operation = action,
                        ResultType = resultType,
                        ErrorCode = channel.ErrorCode.ToString(),
                        ErrorInfo = strError,
                        Entity = entity,
                    };
                    doc.Add(messageItem);

                    // 微调
                    if (lRet == 0 && action == "return")
                        messageItem.ErrorInfo = "";

                    if (lRet == -1)
                    {
                        /*
                        // return 操作如果 API 失败，则要改回原来的 EAS 状态
                        if (action == "return")
                        {
                            var result = SetEAS(entity.UID, entity.Antenna, false);
                            if (result.Value == -1)
                                strError += $"\r\n并且复原 EAS 状态的动作也失败了: {result.ErrorInfo}";
                        }
                        */

                        if (action == "return")
                        {
                            if (channel.ErrorCode == ErrorCode.NotBorrowed)
                            {
                                // TODO: 这里不知是普通状态还是 warning 合适。warning 是否比较强烈了
                                messageItem.ResultType = "warning";
                                messageItem.ErrorCode = ErrorCode.NotBorrowed.ToString();
                                // 界面警告
                                warnings.Add($"册 '{title}' (尝试还书时发现未曾被借出过): {strError}");
                                // 写入错误日志
                                WpfClientInfo.WriteInfoLog($"读者 {_patron.NameSummary} 尝试还回册 '{title}' 时: {strError}");
                                continue;
                            }
                        }

                        entity.SetError($"{action_name}操作失败: {strError}", "red");
                        // TODO: 这里最好用 title
                        errors.Add($"册 '{title}': {strError}");
                        continue;
                    }

                    if (action == "borrow")
                    {
                        if (borrow_info.Overflows != null && borrow_info.Overflows.Length > 0)
                        {
                            // 界面警告
                            // TODO: 可以考虑归入 overflows 单独语音警告处理。语音要简洁。详细原因可出现在文字警告中
                            // warnings.Add($"册 '{title}' (借书操作发生溢出，请于当日内还书): {string.Join("; ", borrow_info.Overflows)}");

                            // TODO: 详细原因文字可否用稍弱的字体效果来显示？
                            messageItem.ErrorInfo = $"借书操作超越许可，请将本册放回书柜。详细原因： {string.Join("; ", borrow_info.Overflows)}";
                            messageItem.ResultType = "warning";
                            messageItem.ErrorCode = "overflow";
                            // 写入错误日志
                            WpfClientInfo.WriteInfoLog($"读者 {_patron.NameSummary} 借阅 '{title}' 时发生超越许可: {strError}");
                        }
                    }

                    if (action == "borrow")
                        borrows.Add(title);
                    if (action == "return")
                        returns.Add(title);

                    /*
                    // borrow 操作，API 之后才修改 EAS
                    // 注: 如果 API 成功但修改 EAS 动作失败(可能由于读者从读卡器上过早拿走图书导致)，读者会无法把本册图书拿出门禁。遇到此种情况，读者回来补充修改 EAS 一次即可
                    if (action == "borrow")
                    {
                        var result = SetEAS(entity.UID, entity.Antenna, action == "return");
                        if (result.Value == -1)
                        {
                            entity.SetError($"虽然{action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}", "yellow");
                            errors.Add($"册 '{entity.PII}' {action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}");
                        }
                    }
                    */

                    // 刷新显示
                    {
                        if (item_records?.Length > 0)
                            entity.SetData(entity.ItemRecPath, item_records[0]);

                        if (entity.Error != null)
                            continue;

                        string message = $"{action_name}成功";
                        if (lRet == 1 && string.IsNullOrEmpty(strError) == false)
                            message = strError;
                        entity.SetError(message,
                            lRet == 1 ? "yellow" : "green");
                        success_count++;
                        // 刷新显示。特别是一些关于借阅日期，借期，应还日期的内容
                    }
                }

                if (progress != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.ProgressBar.Visibility = Visibility.Collapsed;
                        // progress.ProgressBar.Value = progress.ProgressBar.Maximum;
                    }));
                }

                // 修改 borrowable
                // booksControl.SetBorrowable();

#if NO
                if (errors.Count > 0)
                {
                    // TODO: 成功和出错可能会同时存在

                    string error = StringUtil.MakePathList(errors, "\r\n");
                    string message = $"操作出错 {errors.Count} 个";
                    if (success_count > 0)
                        message += $"，成功 {success_count} 个";
                    if (skip_count > 0)
                        message += $" (另有 {skip_count} 个被忽略)";

                    if (errors.Count > 0)
                        message += $"\r\n出错:\r\n" + error;

                    DisplayError(ref progress, message);
                    App.CurrentApp.Speak(message);
                    return; // new NormalResult { Value = -1, ErrorInfo = StringUtil.MakePathList(errors, "; ") };
                }
                else
#endif
                {
#if NO
                    // 成功
                    string backColor = "green";
                    string message = "";

                    if (success_count > 0)
                        message = $"{patron_name} 操作成功 {success_count} 笔";
                    if (errors.Count > 0)
                    {
                        message += "\r\n";
                        message += $"操作出错 {errors.Count} 个";

                        backColor = "red";
                    }
                    if (warnings.Count > 0)
                    {
                        message += "\r\n";
                        message += $"操作警告 {warnings.Count} 个";

                        backColor = "yellow";
                    }

                    string speak = $"出纳完成";

                    /*
                    if (skip_count > 0)
                    {
                        message += "\r\n";
                        message += $" (另有 {skip_count} 笔被忽略)";
                    }

                    if (skip_count > 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"全部 {skip_count} 笔出纳操作被忽略";
                        speak = $"出纳失败";
                    }
                    if (skip_count == 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"请先把图书放到读卡器上，再进行 出纳 操作";
                        speak = $"出纳失败";
                    }
                    */

                    if (errors.Count > 0)
                        message += $"\r\n出错:\r\n" + MakeList(errors);

                    if (warnings.Count > 0)
                        message += $"\r\n警告:\r\n" + MakeList(warnings);

                    if (returns.Count > 0)
                        message += $"\r\n还书:\r\n" + MakeList(returns);

                    if (borrows.Count > 0)
                        message += $"\r\n借书:\r\n" + MakeList(borrows);
#endif
                    string speak = "";
                    if (progress != null)
                    {
                        Application.Current.Dispatcher.Invoke(new Action(() =>
                        {
                            // DisplayError(ref progress, message, backColor);
                            progress.MessageDocument = doc.BuildDocument(patron_name, 18, out speak);
                            progress = null;
                        }));
                    }

                    // 重新装载读者信息和显示
                    // DoorItem.DisplayCount(_all, _adds, _removes, App.CurrentApp.Doors);
                    ShelfData.RefreshCount();

                    App.CurrentApp.Speak(speak);
                }

                return; // new NormalResult { Value = success_count };
            }
            finally
            {
                App.CurrentApp.ReturnChannel(channel);
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    if (progress != null)
                        progress.Close();
                }));
                if (clearPatron)
                    PatronClear(false);
            }
        }


		        // TODO: 报错信息尝试用 FlowDocument 改造
        // 尝试进行一次还书操作
        void TryReturn(ProgressWindow progress,
            List<Entity> entities)
        {
            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in entities)
            {
                actions.Add(new ActionInfo { Entity = entity, Action = "return" });
            }

            LibraryChannel channel = App.CurrentApp.GetChannel();
            try
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress.ProgressBar.Value = 0;
                    progress.ProgressBar.Minimum = 0;
                    progress.ProgressBar.Maximum = actions.Count;
                }));

                // TODO: 准备工作：把涉及到的 Entity 对象的字段填充完整
                // 检查 PII 是否都具备了

                int skip_count = 0;
                int success_count = 0;
                List<string> errors = new List<string>();
                List<string> borrows = new List<string>();
                List<string> returns = new List<string>();
                foreach (ActionInfo info in actions)
                {
                    string action = info.Action;
                    Entity entity = info.Entity;

                    string action_name = "借书";
                    if (action == "return")
                        action_name = "还书";
                    else if (action == "renew")
                        action_name = "续借";

                    long lRet = 0;
                    string strError = "";
                    string[] item_records = null;
                    string[] biblio_records = null;

                    if (action == "return")
                    {
                        // 智能书柜不使用 EAS 状态。可以考虑统一修改为 EAS Off 状态？

                        entity.Waiting = true;
                        lRet = channel.Return(null,
                            "return",
                            "", // _patron.Barcode,
                            entity.PII,
                            entity.ItemRecPath,
                            false,
                            "item,reader,biblio", // style,
                            "xml", // item_format_list
                            out item_records,
                            "xml",
                            out string[] reader_records,
                            "summary",
                            out biblio_records,
                            out string[] dup_path,
                            out string output_reader_barcode,
                            out ReturnInfo return_info,
                            out strError);
                    }

                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.ProgressBar.Value++;
                    }));

                    if (biblio_records != null && biblio_records.Length > 0)
                        entity.Title = biblio_records[0];

                    string title = entity.PII;
                    if (string.IsNullOrEmpty(entity.Title) == false)
                        title += " (" + entity.Title + ")";

                    // TODO: 各种情况的返回值和错误码
                    if (lRet == -1)
                    {
                        /*
                        // return 操作如果 API 失败，则要改回原来的 EAS 状态
                        if (action == "return")
                        {
                            var result = SetEAS(entity.UID, entity.Antenna, false);
                            if (result.Value == -1)
                                strError += $"\r\n并且复原 EAS 状态的动作也失败了: {result.ErrorInfo}";
                        }
                        */

                        if (channel.ErrorCode == ErrorCode.NotBorrowed)
                        {

                        }
                        else
                        {
                            entity.SetError($"{action_name}操作失败: {strError}", "red");
                            // TODO: 这里最好用 title
                            errors.Add($"册 '{title}': {strError}");
                        }
                        continue;
                    }

                    if (action == "borrow")
                        borrows.Add(title);
                    if (action == "return")
                        returns.Add(title);

                    // TODO: 把 _adds 和 _removes 归入 _all
                    // 是否一边处理一边动态修改 _all?
                    if (action == "return")
                        ShelfData.Add(ShelfData.All, entity);
                    else
                        ShelfData.Remove(ShelfData.All, entity);

                    ShelfData.Remove(ShelfData.Adds, entity);
                    ShelfData.Remove(ShelfData.Removes, entity);

                    /*
                    // borrow 操作，API 之后才修改 EAS
                    // 注: 如果 API 成功但修改 EAS 动作失败(可能由于读者从读卡器上过早拿走图书导致)，读者会无法把本册图书拿出门禁。遇到此种情况，读者回来补充修改 EAS 一次即可
                    if (action == "borrow")
                    {
                        var result = SetEAS(entity.UID, entity.Antenna, action == "return");
                        if (result.Value == -1)
                        {
                            entity.SetError($"虽然{action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}", "yellow");
                            errors.Add($"册 '{entity.PII}' {action_name}操作成功，但修改 EAS 动作失败: {result.ErrorInfo}");
                        }
                    }
                    */

                    // 刷新显示
                    {
                        if (item_records?.Length > 0)
                            entity.SetData(entity.ItemRecPath, item_records[0]);

                        if (entity.Error != null)
                            continue;

                        string message = $"{action_name}成功";
                        if (lRet == 1 && string.IsNullOrEmpty(strError) == false)
                            message = strError;
                        entity.SetError(message,
                            lRet == 1 ? "yellow" : "green");
                        success_count++;
                        // 刷新显示。特别是一些关于借阅日期，借期，应还日期的内容
                    }
                }

                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress.ProgressBar.Visibility = Visibility.Collapsed;
                    // progress.ProgressBar.Value = progress.ProgressBar.Maximum;
                }));

                // 修改 borrowable
                // booksControl.SetBorrowable();

                if (errors.Count > 0)
                {
                    string error = StringUtil.MakePathList(errors, "\r\n");
                    string message = $"操作出错 {errors.Count} 个";
                    if (success_count > 0)
                        message += $"，成功 {success_count} 个";
                    if (skip_count > 0)
                        message += $" (另有 {skip_count} 个被忽略)";

                    if (errors.Count > 0)
                        message += $"\r\n出错:\r\n" + error;

                    DisplayError(ref progress, message);
                    App.CurrentApp.Speak(message);
                    return; // new NormalResult { Value = -1, ErrorInfo = StringUtil.MakePathList(errors, "; ") };
                }
                else
                {
                    /*
                    // 成功
                    string backColor = "green";
                    string message = $"{patron_name} 操作成功 {success_count} 笔";
                    string speak = $"出纳完成";

                    if (skip_count > 0)
                        message += $" (另有 {skip_count} 笔被忽略)";
                    if (skip_count > 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"全部 {skip_count} 笔出纳操作被忽略";
                        speak = $"出纳失败";
                    }
                    if (skip_count == 0 && success_count == 0)
                    {
                        backColor = "yellow";
                        message = $"请先把图书放到读卡器上，再进行 出纳 操作";
                        speak = $"出纳失败";
                    }

                    if (returns.Count > 0)
                        message += $"\r\n还书:\r\n" + MakeList(returns);

                    if (borrows.Count > 0)
                        message += $"\r\n借书:\r\n" + MakeList(borrows);

                    DisplayError(ref progress, message, backColor);

                    // 重新装载读者信息和显示
                    // var task = FillPatronDetail(true);
                    this.doorControl.DisplayCount(_all, _adds, _removes);

                    App.CurrentApp.Speak(speak);
                    */
                }

                return; // new NormalResult { Value = success_count };
            }
            finally
            {
                App.CurrentApp.ReturnChannel(channel);
            }
        }


		        public void InitializeButtons(XmlDocument cfg_dom,
            List<DoorItem> items)
        {
            /*
            string cfg_filename = App.ShelfFilePath;
            XmlDocument cfg_dom = new XmlDocument();
            cfg_dom.Load(cfg_filename);
            */

            XmlNodeList shelfs = cfg_dom.DocumentElement.SelectNodes("shelf");

            this.grid.ColumnDefinitions.Clear();
            this.grid.RowDefinitions.Clear();

            // 获得一个 shelf 元素下 door 数量的最多那个
            int max_doors = 0;
            foreach (XmlElement shelf in shelfs)
            {
                int current = shelf.SelectNodes("door").Count;
                if (current > max_doors)
                    max_doors = current;
            }

            // int shelf_width = total_width / Math.Max(1, shelfs.Count);
            // int level_height = 100;
            bool rowDefinitionCreated = false;
            // 初始化 Definitions
            foreach (XmlElement shelf in shelfs)
            {
                this.grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(100) });

                // TODO: 这里要用具有最多 door 元素的 shelf 元素来获得数字
                if (rowDefinitionCreated == false)
                {
                    /*
                    XmlNodeList doors = shelf.SelectNodes("door");
                    // level_height = total_height / Math.Max(1, doors.Count);
                    foreach (XmlElement door in doors)
                    {
                        this.grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(100) });
                    }
                    */
                    for (int i = 0; i < max_doors; i++)
                    {
                        this.grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(100) });
                    }

                    rowDefinitionCreated = true;
                }
            }

            // 填充 Buttons
            int index = 0;
            int column = 0;
            foreach (XmlElement shelf in shelfs)
            {
                XmlNodeList doors = shelf.SelectNodes("door");
                int row = 0;
                foreach (XmlElement door in doors)
                {
                    string door_name = door.GetAttribute("name");

                    Button button = new Button
                    {
                        Name = $"button_{column}_{row}",
                        // Height = level_height,
                        // Content = door_name,
                    };

                    /*
                    var block = BuildTextBlock();
                    SetBlockText(block, door_name, "0", null, null);
                    */

                    var template = this.Resources["ButtonTemplate"];

                    // button.Children.Add(block);
                    button.SetValue(Button.TemplateProperty, template);
                    // button.SetValue(Grid.prop.ContentProperty, block);
                    button.SetValue(Grid.RowProperty, row);
                    button.SetValue(Grid.ColumnProperty, column);
                    button.Click += Button_Click;

                    /*
                    ParseLockString(door.GetAttribute("lock"), out string lockName, out int lockIndex);
                    ParseLockString(door.GetAttribute("antenna"), out string readerName, out int antenna);

                    var tag = new Door
                    {
                        Name = door_name,
                        LockName = lockName,
                        LockIndex = lockIndex,
                        ReaderName = readerName,
                        Antenna = antenna,
                        Button = button
                    };
                    */

                    button.DataContext = items[index++];

                    /*
                    _doors.Add(tag);

                    button.Tag = tag;
                    */
                    this.grid.Children.Add(button);
                    row++;
                }

                column++;
            }

            /*
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            this.grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });

            Button button = new Button
            {
                Name = "button1",
                Height = 100,
                Content = "1",
            };
            button.SetValue(Grid.RowProperty, 0);
            //button.SetValue(Grid.ColumnProperty, 0);
            this.grid.Children.Add(button);
            */

            InitialSize();
        }


		        void SetSize(Size size)
        {
            double row_height = size.Height / Math.Max(1, this.grid.RowDefinitions.Count);
            foreach (var row in this.grid.RowDefinitions)
            {
                row.Height = new GridLength(row_height);
            }
            double column_width = size.Width / Math.Max(1, this.grid.ColumnDefinitions.Count);
            foreach (var column in this.grid.ColumnDefinitions)
            {
                column.Width = new GridLength(column_width);
            }
        }


		~~~~~~~~~~~

		        // 关门，或者更换读者的时候，向服务器提交出纳请求
        // parameters:
        //      clearPatron 操作完成后是否自动清除右侧的读者信息
        async Task SubmitCheckInOut(
            string strStyle = "clearPatron")
        {
            bool clearPatron = false;
            bool silence = false;

            if (StringUtil.IsInList("clearPatron", strStyle))
                clearPatron = true;
            if (StringUtil.IsInList("silence", strStyle))
                silence = true;
            bool verifyDoorClosing = StringUtil.IsInList("verifyDoorClosing", strStyle);

        REDO:
            List<ActionInfo> actions = new List<ActionInfo>();
            foreach (var entity in ShelfData.Adds)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo
                {
                    Entity = entity,
                    Action = "return",
                    Operator = GetOperator()
                });
                // 没有更新的，才进行一次 transfer
                if (ShelfData.Find(ShelfData.Changes, entity.UID).Count == 0)
                {
                    actions.Add(new ActionInfo
                    {
                        Entity = entity,
                        Action = "transfer",
                        CurrentShelfNo = ShelfData.GetShelfNo(entity),
                        Operator = GetOperator()
                    });
                }
            }
            foreach (var entity in ShelfData.Changes)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                // 更新
                actions.Add(new ActionInfo
                {
                    Entity = entity,
                    Action = "transfer",
                    CurrentShelfNo = ShelfData.GetShelfNo(entity),
                    Operator = GetOperator()
                });
            }
            foreach (var entity in ShelfData.Removes)
            {
                if (ShelfData.BelongToNormal(entity) == false)
                    continue;
                actions.Add(new ActionInfo
                {
                    Entity = entity,
                    Action = "borrow",
                    Operator = GetOperator()
                });
            }

            if (actions.Count == 0)
                return;  // 没有必要处理

            // 关闭以前残留的对话框
            CloseDialogs();

            ProgressWindow progress = null;
            string patron_name = "";
            patron_name = _patron.PatronName;

            if (silence == false)
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress = new ProgressWindow();
                    progress.MessageText = "正在处理，请稍候 ...";
                    progress.Owner = Application.Current.MainWindow;
                    progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    progress.Closed += Progress_Closed;
                    progress.Width = Math.Min(700, this.ActualWidth);
                    progress.Height = Math.Min(500, this.ActualHeight);
                    progress.Show();
                    AddLayer();
                }));
            }

            // 检查门是否全关闭
            if (verifyDoorClosing && silence == false)
            {
                if (ShelfData.OpeningDoorCount > 0)
                {
                    // 检查门是否为关闭状态？
                    await Task.Run(() =>
                    {
                        while (ShelfData.OpeningDoorCount > 0)
                        {
                            // TODO: 如何中断？
                            //if (_initialCancelled)
                            //    break;
                            DisplayMessage(progress, "请关闭全部柜门，以完成请求", "yellow");
                            Thread.Sleep(1000);
                        }
                    });
                    // 确保全关闭后，回到开头重做
                    if (progress != null)
                        progress.Close();
                    goto REDO;
                }
            }

            bool patron_filled = false;

            // 检查读者卡状态是否 OK
            if (IsPatronOK("open", out string check_message) == false)
            {
                /*
                if (string.IsNullOrEmpty(check_message))
                    check_message = $"读卡器上的当前读者卡状态不正确。无法进行 checkin/out 操作";

                DisplayError(ref progress, check_message);
                return;
                */
            }
            else
                patron_filled = true;

            try
            {
                var result = ShelfData.SubmitCheckInOut(
                    (min, max, value) =>
                    {
                        if (progress != null)
                        {
                            Application.Current.Dispatcher.Invoke(new Action(() =>
                            {
                                if (min == -1 && max == -1 && value == -1)
                                    progress.ProgressBar.Visibility = Visibility.Collapsed;
                                if (min != -1)
                                    progress.ProgressBar.Minimum = min;
                                if (max != -1)
                                    progress.ProgressBar.Maximum = max;
                                if (value != -1)
                                    progress.ProgressBar.Value = value;
                            }));
                        }
                    },
                    //_patron.Barcode,
                    //_patron.PatronName,
                    actions,
                    patron_filled);
                if (result.Value == -1)
                {
                    DisplayError(ref progress, result.ErrorInfo);
                    return;
                }

                string speak = "";
                if (progress != null && result.Value == 1 && result.MessageDocument != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.MessageDocument = result.MessageDocument.BuildDocument(patron_name, 18, out speak);
                        MemoryDialog(progress); // 记住对话框，以便后面可以补充关闭
                        progress = null;
                    }));
                }

                if (string.IsNullOrEmpty(speak) == false)
                    App.CurrentApp.Speak(speak);
            }
            finally
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    if (progress != null)
                        progress.Close();
                }));
                if (clearPatron)
                    PatronClear(false);
            }
        }


		~~~~~~~~~

		        // 从 shelf.xml 配置文件中归纳出所有的天线编号
        public static string GetAntennaList()
        {
            if (ShelfCfgDom == null)
                return "";

            List<string> antenna_list = new List<string>();

            XmlNodeList doors = ShelfCfgDom.DocumentElement.SelectNodes("shelf/door");
            foreach (XmlElement door in doors)
            {
                DoorItem.ParseReaderString(door.GetAttribute("antenna"),
                    out string readerName,
                    out int antenna);
                antenna_list.Add(antenna.ToString());
            }

            StringUtil.RemoveDup(ref antenna_list, false);
            return StringUtil.MakePathList(antenna_list, "|");

            /*
            List<string> antenna_list = new List<string>();
            string cfg_filename = ShelfData.ShelfFilePath;
            XmlDocument cfg_dom = new XmlDocument();
            try
            {
                cfg_dom.Load(cfg_filename);

                XmlNodeList doors = cfg_dom.DocumentElement.SelectNodes("shelf/door");
                foreach (XmlElement door in doors)
                {
                    DoorItem.ParseLockString(door.GetAttribute("antenna"),
                        out string readerName,
                        out int antenna);
                    antenna_list.Add(antenna.ToString());
                }

                StringUtil.RemoveDup(ref antenna_list, false);
                return StringUtil.MakePathList(antenna_list, "|");
            }
            catch (FileNotFoundException)
            {
                return "";
            }
            catch (Exception ex)
            {
                this.SetError("cfg", $"装载配置文件 shelf.xml 时出现异常: {ex.Message}");
                return "";
            }
            */
        }


		~~~~~~~~~~~~~

		        // 向服务器提交 actions 中存储的全部出纳请求
        // parameters:
        //      clearPatron 操作完成后是否自动清除右侧的读者信息
        async Task SubmitCheckInOut(
            string strStyle = "")
        {
            bool silence = false;

            if (StringUtil.IsInList("silence", strStyle))
                silence = true;
            bool verifyDoorClosing = StringUtil.IsInList("verifyDoorClosing", strStyle);

        REDO:

            if (ShelfData.Actions.Count == 0)
                return;  // 没有必要处理

            // 关闭以前残留的对话框
            CloseDialogs();

            ProgressWindow progress = null;
            //string patron_name = "";
            //patron_name = _patron.PatronName;

            if (silence == false)
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    progress = new ProgressWindow();
                    progress.MessageText = "正在处理，请稍候 ...";
                    progress.Owner = Application.Current.MainWindow;
                    progress.WindowStartupLocation = WindowStartupLocation.CenterOwner;
                    progress.Closed += Progress_Closed;
                    progress.Width = Math.Min(700, this.ActualWidth);
                    progress.Height = Math.Min(500, this.ActualHeight);
                    progress.Show();
                    AddLayer();
                }));
            }

#if NO
            // 检查门是否全关闭
            if (verifyDoorClosing && silence == false)
            {
                if (ShelfData.OpeningDoorCount > 0)
                {
                    // 检查门是否为关闭状态？
                    await Task.Run(() =>
                    {
                        while (ShelfData.OpeningDoorCount > 0)
                        {
                            // TODO: 如何中断？
                            //if (_initialCancelled)
                            //    break;
                            DisplayMessage(progress, "请关闭全部柜门，以完成请求", "yellow");
                            Thread.Sleep(1000);
                        }
                    });
                    // 确保全关闭后，回到开头重做
                    if (progress != null)
                        progress.Close();
                    goto REDO;
                }
            }

#endif

#if NO
            bool patron_filled = false;

            // 检查读者卡状态是否 OK
            if (IsPatronOK("open", out string check_message) == false)
            {
                /*
                if (string.IsNullOrEmpty(check_message))
                    check_message = $"读卡器上的当前读者卡状态不正确。无法进行 checkin/out 操作";

                DisplayError(ref progress, check_message);
                return;
                */
            }
            else
                patron_filled = true;
#endif
            try
            {
                var result = ShelfData.SubmitCheckInOut(
                    (min, max, value) =>
                    {
                        if (progress != null)
                        {
                            Application.Current.Dispatcher.Invoke(new Action(() =>
                            {
                                if (min == -1 && max == -1 && value == -1)
                                    progress.ProgressBar.Visibility = Visibility.Collapsed;
                                if (min != -1)
                                    progress.ProgressBar.Minimum = min;
                                if (max != -1)
                                    progress.ProgressBar.Maximum = max;
                                if (value != -1)
                                    progress.ProgressBar.Value = value;
                            }));
                        }
                    },
                    //_patron.Barcode,
                    //_patron.PatronName,
                    ShelfData.Actions);
                if (result.Value == -1)
                {
                    DisplayError(ref progress, result.ErrorInfo);
                    return;
                }

                string speak = "";
                if (progress != null && result.Value == 1 && result.MessageDocument != null)
                {
                    Application.Current.Dispatcher.Invoke(new Action(() =>
                    {
                        progress.MessageDocument = result.MessageDocument.BuildDocument(18, out speak);
                        MemoryDialog(progress); // 记住对话框，以便后面可以补充关闭
                        progress = null;
                    }));
                }

                if (string.IsNullOrEmpty(speak) == false)
                    App.CurrentApp.Speak(speak);
            }
            finally
            {
                Application.Current.Dispatcher.Invoke(new Action(() =>
                {
                    if (progress != null)
                        progress.Close();
                }));
                //if (clearPatron)
                //    PatronClear(false);
            }
        }


		~~~~~~~~~~~~~~

		        // 启动后台任务。
        // 后台任务负责监视 RFID 中心的标签
        public static void Start(
            CancellationToken token)
        {
            Base.ShortWaitTime = TimeSpan.FromMilliseconds(10);
            Base.LongWaitTime = TimeSpan.FromMilliseconds(2000);
            Base.Start((channel) =>
            {
                // TODO: 看调用栈，如果是上层 GetState() 调用，就要免去检查 State 这一步
                if (_checkState)
                {
                    var result = channel.Object.GetState("");
                    if (result.Value == -1)
                        throw new Exception($"RFID 中心当前处于 {result.ErrorCode} 状态({result.ErrorInfo})");
                }
                channel.Started = true;

                channel.Object.EnableSendKey(false);
            },
            () =>
            {
                if (_pause == true)
                {
                    Base.TriggerSetError(null,
new SetErrorEventArgs
{
    Error = "RFID 功能已暂停"
});
                    return true;
                }

                if (string.IsNullOrEmpty(Base.Url))
                {
                    Base.TriggerSetError(null,
                        new SetErrorEventArgs
                        {
                            Error = "RFID 中心 URL 尚未配置(因此无法从 RFID 读卡器读取信息)"
                        });
                    return true;
                }

                return false;
            },
            (channel) =>
            {
                string style = $"session:{Base.GetHashCode()}";
                /*
                if (string.IsNullOrEmpty(_antennaList) == false)
                    style += ",antenna:" + _antennaList;
                    */

                var readerNameList = _readerNameList;
                if (string.IsNullOrEmpty(readerNameList) == false)
                {

                    var result = channel?.Object?.ListTags(readerNameList, style);
                    if (result.Value == -1)
                        Base.TriggerSetError(result,
                            new SetErrorEventArgs { Error = result.ErrorInfo });
                    else
                        Base.TriggerSetError(result,
                            new SetErrorEventArgs { Error = null }); // 清除以前的报错

                    lock (_syncRoot)
                    {
                        if (ListTags != null)
                        {
                            // 先记忆
                            _lastTags = result.Results;

                            // 注意 result.Value == -1 时也会触发这个事件
                            ListTags(channel, new ListTagsEventArgs
                            {
                                ReaderNameList = readerNameList,
                                Result = result
                            });
                        }
                        else
                            _lastTags = null;
                    }

                }

                // 检查门状态
                if (LockCommands != null)
                {
                    List<GetLockStateResult> errors = new List<GetLockStateResult>();
                    List<LockState> states = new List<LockState>();
                    {
                        // parameters:
                        //      lockNameParam   为 "锁控板名字.卡编号.锁编号"。
                        //                      其中卡编号部分可以是 "1" 也可以是 "1|2" 这样的形态
                        //                      其中锁编号部分可以是 "1" 也可以是 "1|2|3|4" 这样的形态
                        //                      如果缺乏卡编号和锁编号部分，缺乏的部分默认为 "1"
                        var lock_result = channel?.Object?.GetShelfLockState(LockCommands);
                        if (lock_result.Value == -1)
                            Base.TriggerSetError(lock_result,
                                new SetErrorEventArgs { Error = lock_result.ErrorInfo });
                        else
                            Base.TriggerSetError(lock_result,
                                new SetErrorEventArgs { Error = null }); // 清除以前的报错
                        if (lock_result.Value == -1)
                        {
                            // 注意 lock_result.Value == -1 时也会触发这个事件
                            ListLocks?.Invoke(channel, new ListLocksEventArgs
                            {
                                Result = lock_result
                            });
                        }
                        if (lock_result.States != null)
                            states.AddRange(lock_result.States);
                    }

                    if (states.Count > 0)
                    {
                        // 注意 lock_result.Value == -1 时也会触发这个事件
                        ListLocks?.Invoke(channel, new ListLocksEventArgs
                        {
                            Result = new GetLockStateResult { States = states }
                        });
                    }
                    // 门锁状态就绪
                    _lockReady = true;
                }
            },
            token);
        }


		~~~
		        // 增加了无标签时延迟等待功能。敏捷响应
        public ListTagsResult ListTags(string reader_name, string style)
        {
            if (Program.Rfid.Pause)
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = "RFID 功能处于暂停状态",
                    ErrorCode = "paused"
                };

            string lockNameList = StringUtil.GetParameterByPrefix(style, "getLockState");
            if (lockNameList != null)
                lockNameList = StringUtil.UnescapeString(lockNameList);

            Program.Rfid.IncApiCount();
            try
            {
                if (Program.Rfid.Pause)
                    return new ListTagsResult
                    {
                        Value = -1,
                        ErrorInfo = "RFID 功能处于暂停状态",
                        ErrorCode = "paused"
                    };

                string session_id = StringUtil.GetParameterByPrefix(style, "session");

                TimeSpan length = TimeSpan.FromSeconds(2);

                ListTagsResult result = null;
                GetLockStateResult lock_result = null;

                string current_uids = "";
                DateTime start = DateTime.Now;
                while (DateTime.Now - start < length
                    || result == null)
                {
                    if (string.IsNullOrEmpty(reader_name) == false)
                    {
                        result = _listTags(reader_name, style);

                        if (result != null && result.Results != null)
                            current_uids = BuildUids(result.Results);
                        else
                            current_uids = "";

                        // TODO: 这里的比较应该按照 Session 来进行
                        // 只要本次和上次 tag 数不同，立刻就返回
                        if (CompareLastUids(session_id, current_uids))
                        {
                            SetLastUids(session_id, current_uids);
                            return result;
                        }

                        if (result.Value == -1)
                        {
                            return result;
                        }
                    }
                    else
                        result = new ListTagsResult();

                    // 检测一下门锁状态是否有变化
                    // 目前是 1:1 次数分配
                    if (lockNameList != null)
                    {
                        lock_result = GetShelfLockState(lockNameList);
                        // 这里的疑问是，如果 _listTags 没有出错，是否应该坚持返回正确结果？
                        if (lock_result.Value != -1)
                        {
                            string current_states = BuildStateString(lock_result.States);
                            if (CompareLastUids(session_id + "_lock", current_states))
                            {
                                SetLastUids(session_id + "_lock", current_states);
                                return new ListTagsResult { GetLockStateResult = lock_result };
                            }
                        }
                    }

                    /*
                    // TODO: 如果本次和上次都是 2，是否立即返回？可否先对比一下 uid，有差别再返回?
                    if (result.Results != null
                        && result.Results.Count > 0)
                    {
                        SetLastUids(current_uids);
                        return result;
                    }
                    */
                    Thread.Sleep(10);  // 10? 200?
                }

                SetLastUids(session_id, current_uids);
                if (lockNameList != null && lock_result != null)
                    result.GetLockStateResult = lock_result;
                return result;
            }
            catch (Exception ex)
            {
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = $"ListTags() 出现异常:{ex.Message}"
                };
            }
            finally
            {
                Program.Rfid.DecApiCount();
            }
        }


		~~~
		第二个版本。先判断 inventory

		        // 增加了无标签时延迟等待功能。敏捷响应
        public ListTagsResult ListTags(string reader_name, string style)
        {
            if (Program.Rfid.Pause)
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = "RFID 功能处于暂停状态",
                    ErrorCode = "paused"
                };

            string lockNameList = StringUtil.GetParameterByPrefix(style, "getLockState");
            if (lockNameList != null)
                lockNameList = StringUtil.UnescapeString(lockNameList);

            Program.Rfid.IncApiCount();
            try
            {
                if (Program.Rfid.Pause)
                    return new ListTagsResult
                    {
                        Value = -1,
                        ErrorInfo = "RFID 功能处于暂停状态",
                        ErrorCode = "paused"
                    };

                string session_id = StringUtil.GetParameterByPrefix(style, "session");

                TimeSpan length = TimeSpan.FromSeconds(2);

                ListTagsResult result = null;
                GetLockStateResult lock_result = null;

                string current_uids = "";
                DateTime start = DateTime.Now;
                while (DateTime.Now - start < length
                    || result == null)
                {
                    // 执行 inventory
                    if (string.IsNullOrEmpty(reader_name) == false)
                    {
                        result = _listTags(reader_name, style);
                    }
                    else
                        result = new ListTagsResult();

                    // 判断 inventory 结果
                    if (string.IsNullOrEmpty(reader_name) == false)
                    {
                        if (result != null && result.Results != null)
                            current_uids = BuildUids(result.Results);
                        else
                            current_uids = "";

                        // TODO: 这里的比较应该按照 Session 来进行
                        // 只要本次和上次 tag 数不同，立刻就返回
                        if (CompareLastUids(session_id, current_uids))
                        {
                            SetLastUids(session_id, current_uids);
                            return result;
                        }

                        if (result.Value == -1)
                        {
                            return result;
                        }
                    }

                    // 执行门锁状态获取
                    // 目前是 1:1 次数分配
                    if (lockNameList != null)
                    {
                        lock_result = GetShelfLockState(lockNameList);
                        // 从此开始 result.GetLockStateResult 就有值了
                        result.GetLockStateResult = lock_result;
                    }

                    // 判断门锁状态
                    if (lockNameList != null)
                    {
                        // 这里的疑问是，如果 _listTags 没有出错，是否应该坚持返回正确结果？
                        if (lock_result.Value != -1)
                        {
                            string current_states = BuildStateString(lock_result.States);
                            if (CompareLastUids(session_id + "_lock", current_states))
                            {
                                SetLastUids(session_id + "_lock", current_states);
                                return result;
                            }
                        }
                    }

                    /*
                    // TODO: 如果本次和上次都是 2，是否立即返回？可否先对比一下 uid，有差别再返回?
                    if (result.Results != null
                        && result.Results.Count > 0)
                    {
                        SetLastUids(current_uids);
                        return result;
                    }
                    */
                    Thread.Sleep(10);  // 10? 200?
                }

                SetLastUids(session_id, current_uids);
                return result;
            }
            catch (Exception ex)
            {
                return new ListTagsResult
                {
                    Value = -1,
                    ErrorInfo = $"ListTags() 出现异常:{ex.Message}"
                };
            }
            finally
            {
                Program.Rfid.DecApiCount();
            }
        }
