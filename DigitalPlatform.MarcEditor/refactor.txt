
2025/11/25

MarcEditor.ReadOnly 直接使用 MarcControl 的 ReadOnly 成员。

MarcEditor.BidiAdjust 属性删除。原来是为了 Unicode 处理中的困难设计的，现在问题不存在了

2025/12/9
左侧 label 显示
Ctrl+M 定长模板
回车是到下一行还是插入一个字段结束符，可以配置
字段名和指示符应该允许单独指定 FixedFont

~~~
2025/12/16
现有 FireFieldSelectChanged() 机制只根据 careinfo.ChildIndex 变化触发。也就是说
无法根据键盘输入(和剪切粘贴等)修改字段名子字段名而触发。
作为对现有 FireFieldSelectChanged() 机制的补充：
捕获 TextChange 事件后，判断 CaretFieldIndex 所在的字段名(和 Caret 所在的子字段名)和以前记忆的字段名是否
一致。如果不一致则触发 FieldSelectChanged 事件。这个过程异步做，避免拖慢 base 类
的处理键盘输入的过程。
CaretFieldIndex 变化后，及时修改存储的这个字段名，以免影响后继的判断。

这个功能的难度在于需要不影响键盘等操作的速度。

目前已经存在 delay update 机制，可以考虑由延迟了的 update 来负责触发检查动作，以节省
CPU 资源。

~~~
在最后一个字段内容上回车，应该到下一行行首可以输入的位置。

~~~
不知何故，MARC 编辑器中一条记录的 001 字段名修改为 201 以后，保存，201 字段跑到了
005 字段的后面。

~~~
C# 脚本中很多地方用了 MarcEditor.Marc = "xxx" 这样的修改编辑器内容的方式。
这样会让编辑历史清空，一旦操作者后悔了要 Undo 就没法 Undo。
建议提供一个 ChangeMarc(string text) 这样的函数，效果是不清空操作历史。

另外，可以考虑实现一种算法，把新旧两个字符串，从头尾两个方向往中间逼近，寻找两端没有变化
的部分，在调用 ReplaceText() 时只修改中间不同的一段，这样会让编辑历史更简洁。